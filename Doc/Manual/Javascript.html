<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="stylesheet" type="text/css" href="style.css">
<title></title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>

<H1><a name="Javascript">28 SWIG and Javascript</a></H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#Javascript_overview">Overview</a>
<li><a href="#Javascript_preliminaries">Preliminaries</a>
<ul>
<li><a href="#Javascript_running_swig">Running SWIG</a>
<li><a href="#Javascript_running_tests_examples">Running Tests and Examples</a>
<li><a href="#Javascript_known_issues">Known Issues</a>
</ul>
<li><a href="#Javascript_integration">Integration</a>
<ul>
<li><a href="#Javascript_node_extensions">Creating node.js Extensions</a>
<ul>
<li><a href="#Javascript_using_yeoman">Using <code>yeoman</code> to generate a Node-API skeleton</a>
<li><a href="#Javascript_troubleshooting">Troubleshooting</a>
</ul>
<li><a href="#Javascript_embedded_webkit">Embedded Webkit</a>
<ul>
<li><a href="#Javascript_osx">Mac OS X</a>
<li><a href="#Javascript_gtk">GTK</a>
</ul>
<li><a href="#Javascript_applications_webkit">Creating Applications with node-webkit</a>
</ul>
<li><a href="#Javascript_examples">Examples</a>
<ul>
<li><a href="#Javascript_simple_example">Simple</a>
<li><a href="#Javascript_class_example">Class</a>
<li><a href="#Javascript_STL_example">STL Containers</a>
<li><a href="#Javascript_Buffer_example"><code>Buffer</code> and <code>ArrayBuffer</code></a>
</ul>
<li><a href="#Javascript_exceptions">Exceptions</a>
<ul>
<li><a href="#Javascript_jsc_exceptions">Handling Exceptions in JavascriptCore</a>
<li><a href="#Javascript_napi_exceptions">Handling Exceptions in Node-API</a>
</ul>
<li><a href="#Javascript_async">Asynchronous Execution</a>
<ul>
<li><a href="#Javascript_async_persistence">Persistence</a>
<li><a href="#Javascript_async_locking">Locking</a>
<ul>
<li><a href="#Javascript_async_sync_locking">Creating Wrappers that Support Mixing Synchronous and Asynchronous Execution</a>
<li><a href="#Javascript_async_locking_starvation">Avoiding Thread Starvation</a>
<li><a href="#Javascript_async_shared_locking">Custom Locking Example</a>
</ul>
<li><a href="#Javascript_async_reject">Rejecting a Promise from a Typemap</a>
</ul>
<li><a href="#Typescript">Typescript</a>
<li><a href="#Javascript_WASM">WASM</a>
<ul>
<li><a href="#Javascript_WASM_intro">Introduction</a>
<li><a href="#Javascript_WASM_building">Building SWIG Node-API generated wrappers to WASM</a>
<li><a href="#Javascript_WASM_importing">Importing SWIG Node-API generated wrappers built to WASM</a>
<li><a href="#Javascript_WASM_async">Using asynchronous wrappers with WASM</a>
<li><a href="#Javascript_WASM_differences">Incompatibilities between <code>node-addon-api</code> and <code>emnapi</code></a>
</ul>
<li><a href="#Javascript_code_splitting">Code Splitting</a>
<li><a href="#Javascript_implementation">Implementation</a>
<ul>
<li><a href="#Javascript_source_code">Source Code</a>
<li><a href="#Javascript_code_templates">Code Templates</a>
<li><a href="#Javascript_emitter">Emitter</a>
<li><a href="#Javascript_emitter_states">Emitter states</a>
</ul>
</ul>
</div>
<!-- INDEX -->



<p>This chapter describes SWIG's support of Javascript. It does not cover SWIG basics, but only information that is specific to this module.</p>

<H2><a name="Javascript_overview">28.1 Overview</a></H2>


<p>Javascript is a prototype-based scripting language that is dynamic, weakly typed and has first-class functions. Its arguably the most popular language for web development.
Javascript has gone beyond being a browser-based scripting language and with <a href="https://nodejs.org">node.js</a>, it is also used as a backend development language.</p>
<p>Native Javascript extensions can be used for applications that embed a web-browser view or that embed a Javascript engine (such as <em>node.js</em>). Extending a general purpose web-browser is not possible as this would be a severe security issue.</p>
<p>SWIG Javascript currently supports <strong>JavascriptCore</strong>, the Javascript engine used by <code>Safari/Webkit</code>, and <a href="https://v8.dev/"><strong>v8</strong></a>, which is used by <code>Chromium</code> and <code>node.js</code>.</p>
<p><a href="https://webkit.org/">WebKit</a> is a modern browser implementation available as open-source which can be embedded into an application.
With <a href="https://github.com/rogerwang/node-webkit">node-webkit</a> there is a platform which uses Google's <code>Chromium</code> as Web-Browser widget and <code>node.js</code> for javascript extensions.
</p>

<H2><a name="Javascript_preliminaries">28.2 Preliminaries</a></H2>


<H3><a name="Javascript_running_swig">28.2.1 Running SWIG</a></H3>


<p>Suppose that you defined a SWIG module such as the following:</p>
<div class="code">
<pre>
%module example
%{
#include "example.h"
%}
int gcd(int x, int y);
extern double Foo;</pre>
</div>
<p>To build a Javascript module, run SWIG using the <code>-javascript</code> option and a desired target engine <code>-jsc</code>, <code>-v8</code>, <code>-node</code> or <code>-napi</code>. <code>-v8</code> allows for interfacing with a raw embedded version of V8. In this case, it is up to the user to implement a binary module loading protocol. There are two generators supporting Node.js. The older generator for <code>node</code> is essentially delegating to the <code>v8</code> generator and adds some necessary preprocessor definitions. The more recent <code>-napi</code> generator produces <code>node-addon-api</code> that interfaces to Node.js through Node-API. The V8 generator is more mature, while the Node-API generator offers a number of advantages such as binary stable ABI allowing for publishing of universal binary modules on npm, Electron support and a built-in framework for multi-threading.</p>
<div class="shell">
<pre>
$ swig -javascript -jsc example.i</pre>
</div>
<p>If building a C++ extension, add the -c++ option:</p>
<div class="shell">
<pre>
$ swig -c++ -javascript -jsc example.i</pre>
</div>
<p>The V8 code that SWIG generates requires at least V8 5.0. Keep in mind
that this is the V8 version, not Node.js. To give some perspective, Node.js v6.0
uses V8 5.0, v12.0 - 7.4, v14.0 - 8.1...</p>
<p>The Node-API code that SWIG generates requires Node-API version 6.
This Node-API is available starting from Node.js v10.20 on the v10.x branch,
Node.js v12.17 on the v12.x branch and all versions starting from v14.0. Node-API requires at least C++11.
</p>
<p>The oldest Node version we regularly test with is Node 12.</p>
<p>To generate code for V8, you would run swig like so:</p>
<div class="shell">
<pre>
$ swig -c++ -javascript -v8 example.i</pre>
</div>
<p>This creates a C/C++ source file <code>example_wrap.c</code> or <code>example_wrap.cxx</code>. The generated C source file contains the low-level wrappers that need to be compiled and linked with the rest of your C/C++ application to create an extension module.</p>
<p>The name of the wrapper file is derived from the name of the input file. For example, if the input file is <code>example.i</code>, the name of the wrapper file is <code>example_wrap.c</code>. To change this, you can use the -o option. The wrapped module will export one function which must be called to register the module with the Javascript interpreter. For example, if your module is named <code>example</code> the corresponding initializer for JavascriptCore would be</p>
<div class="code">
<pre>
bool example_initialize(JSGlobalContextRef context, JSObjectRef *exports)</pre>
</div>
<p>and for v8:</p>
<div class="code">
<pre>
void example_initialize(v8::Handle&lt;v8::Object&gt; exports)</pre>
</div>
<p>
<b>Note</b>: be aware that <code>v8</code> has a C++ API, and thus, the generated modules must be compiled as C++.
</p>

<H3><a name="Javascript_running_tests_examples">28.2.2 Running Tests and Examples</a></H3>


<p>The configuration for tests and examples currently supports Linux and Mac only and not MinGW (Windows) yet.</p>
<p>The default interpreter is <code>node.js</code> as it is available on all platforms and convenient to use.</p>
<p>Running the examples with JavascriptCore requires <code>libjavascriptcoregtk-1.0</code> to be installed, e.g., under Ubuntu with</p>
<div class="shell">
<pre>
$ sudo apt-get install libjavascriptcoregtk-1.0-dev</pre>
</div>
<p>Running with <code>V8</code> requires <code>libv8</code>:</p>
<div class="shell">
<pre>
$ sudo apt-get install libnode-dev</pre>
</div>
<p>Running with Node-API requires <code>node-addon-api</code>:</p>
<div class="shell">
  <pre>
$ sudo npm install -g node-addon-api</pre>
</div>
<p>Examples can be run using</p>
<div class="shell">
<pre>
$ make check-javascript-examples ENGINE=jsc</pre>
</div>
<p><code>ENGINE</code> can be <code>node</code>, <code>jsc</code>, <code>v8</code>, or <code>napi</code>.</p>
<p>The test-suite can be run using</p>
<div class="shell">
<pre>
$ make check-javascript-test-suite ENGINE=jsc</pre>
</div>
<p>You can specify a specific <code>V8</code> version for running the examples and tests</p>
<div class="shell">
<pre>
$ make check-javascript-examples V8_VERSION=0x032530 ENGINE=v8</pre>
</div>

<H3><a name="Javascript_known_issues">28.2.3 Known Issues</a></H3>


<p>At the moment, the Javascript generators pass all tests syntactically, i.e., the generated source code compiles. However, there are still remaining runtime issues.</p>

<ul>
    <li><p>Default optional arguments do not work for all targeted interpreters except Node-API</p></li>
    <li><p>Multiple output arguments do not work for JSC</p></li>
    <li><p>C89 incompatibility: the JSC generator might still generate C89 violating code</p></li>
    <li><p><code>long long</code> is not supported except with Node-API</p></li>
    <li><p>Javascript callbacks are not supported</p></li>
    <li><p><code>instanceOf</code> does not work under JSC</p></li>
</ul>

<p>The primary development environment has been Linux (Ubuntu 22.04). Windows and Mac OS X have been tested sporadically. Therefore, the generators might have more issues on those platforms. Please report back any problem you observe to help us improving this module quickly.</p>

<H2><a name="Javascript_integration">28.3 Integration</a></H2>


<p>This chapter gives a short introduction how to use a native Javascript extension: as a <code>node.js</code> module, and as an extension for an embedded Webkit.</p>

<H3><a name="Javascript_node_extensions">28.3.1 Creating node.js Extensions</a></H3>


<p>To install <code>node.js</code> you can download an installer from their <a href="https://launchpad.net/~chris-lea/+archive/node.js">web-site</a> for Mac OS X and Windows. For Linux you can either build the source yourself and run <code>sudo checkinstall</code> or keep to the (probably stone-age) packaged version. For Ubuntu there is a <a href="https://launchpad.net/~chris-lea/+archive/ubuntu/node.js/">PPA</a> available.</p>
<div class="shell">
<pre>
$ sudo add-apt-repository ppa:chris-lea/node.js
$ sudo apt-get update
$ sudo apt-get install nodejs</pre>
</div>
<p>As <code>v8</code> is written in C++ and comes as a C++ library it is crucial to compile your module using the same compiler flags as used for building v8. To make things easier, <code>node.js</code> provides a build tool called <code>node-gyp</code>.</p>
<p>You have to install it using <code>npm</code>:</p>
<div class="shell">
<pre>
$ sudo npm install -g node-gyp</pre>
</div>
<p><code>node-gyp</code> expects a configuration file named <code>binding.gyp</code> which is basically in JSON format and conforms to the same format that is used with Google's build-tool <code>gyp</code>.</p>
<p><code>binding.gyp</code>:</p>
<div class="code">
<pre>
{
  "targets": [
    {
      "target_name": "example",
      "sources": [ "example.cxx", "example_wrap.cxx" ]
    }
  ]
}</pre>
</div>
<p>First create the wrapper using SWIG:</p>
<div class="shell">
<pre>
$ swig -javascript -node -c++ example.i</pre>
</div>
<p>Then run <code>node-gyp build</code> to actually create the module:</p>
<div class="shell">
<pre>
$ node-gyp build</pre>
</div>
<p>This will create a <code>build</code> folder containing the native module. To use the extension you need to 'require' it in your Javascript source file:</p>
<div class="code">
<pre>
require("./build/Release/example")</pre>
</div>
<p>A more detailed explanation is given in the <a href="#Javascript_examples">Examples</a> section.</p>

<H4><a name="Javascript_using_yeoman">28.3.1.1 Using <code>yeoman</code> to generate a Node-API skeleton</a></H4>


<p>If targeting Node-API, the easiest way to bootstrap a project is by using the <code>yeoman</code> generator: </p>
<div class="shell">
<pre>
$ sudo npm install -g yo
$ sudo npm install -g generator-napi-module
$ mkdir example
$ cd example
$ yo napi-module                     # the choice of template is irrelevant, SWIG will replace the C++ code
$ npm install node-addon-api@latest  # the yeoman version is outdated
$ swig -javascript -napi -c++ -o src/example.cc example.i
$ node-gyp configure
$ node-gyp build
</pre>
</div>
<p>There is also the <a href="https://github.com/mmomtchev/node-magickwand"><code>node-magickwand</code></a> project that can be used as a tutorial for building and publishing a complex C++ library to
  npm as a ready-to-use real-world binary module.</p>

<H4><a name="Javascript_exports_file">28.3.1.2 Generating an exports file</a></H4>

<p>The Node-API generator can also automatically generate an exports file with named exports that will be compatible with both CommonJS and ECMAScript 6. This file follows the syntax guidelines set by <a href="https://github.com/nodejs/cjs-module-lexer/">cjs-module-lexer</a>. In order to generate the file, add the <code>-exports</code> CLI option, followed by the path to the compiled shared library - usually <code>../build/Release/<em>module_name</em>.node</code> when using <code>node-gyp</code>. In order to generate this name dynamically, a small JS wrapper may be used. For example when using <code>node-pre-gyp</code>, the following wrapper will load the shared library:</p>

<div class="shell">
<pre>
const binary = require('@mapbox/node-pre-gyp');
const dll = require(binding_path);
module.exports = require(binding_path);
</pre>
</div>

<p>In this case, it will the filename of this wrapper that will have to be specified to <code>-exports</code>.</p>

<H4><a name="Javascript_troubleshooting">28.3.1.3 Troubleshooting</a></H4>


<ul>
<li><em>'module' object has no attribute 'script_main'</em></li>
</ul>
<p>This error happens when <code>gyp</code> is installed as a distribution package. It seems to be outdated. Removing it resolves the problem.</p>
<div class="shell">
<pre>
$ sudo apt-get remove gyp</pre>
</div>

<H3><a name="Javascript_embedded_webkit">28.3.2 Embedded Webkit</a></H3>


<p>Webkit is pre-installed on Mac OS X and available as a library for GTK.</p>

<H4><a name="Javascript_osx">28.3.2.1 Mac OS X</a></H4>


<p>There is general information about programming with WebKit on <a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/DisplayWebContent/DisplayWebContent.html">Apple Developer Documentation</a>. Details about <code>Cocoa</code> programming are not covered here.</p>
<p>An integration of a native extension 'example' would look like this:</p>
<div class="code">
<pre>
#import "appDelegate.h"

extern bool example_initialize(JSGlobalContextRef context, JSObjectRef* exports);


@implementation ExampleAppDelegate

@synthesize webView;

- (void)addGlobalObject:(JSContextRef) context:(NSString *)objectName:(JSObjectRef) theObject {
  JSObjectRef global = JSContextGetGlobalObject(context);
  JSStringRef objectJSName = JSStringCreateWithCFString( (CFStringRef) objectName )
  if ( objectJSName != NULL ) {
    JSObjectSetProperty(context, global, objectJSName, theObject, kJSPropertyAttributeReadOnly, NULL);
    JSStringRelease( objectJSName );
  }
}

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {

  // Start a webview with the bundled index.html file
  NSString *path = [[NSBundle mainBundle] bundlePath];
  NSString *url =  [NSString stringWithFormat: @"file://%@/Contents/Assets/index.html", path];

  WebFrame *webframe = [webView mainFrame];
  JSGlobalContextRef context = [webframe globalContext];

  JSObjectRef example;
  example_initialize(context, &amp;example);
  [self addGlobalObject:context:@"example":example]

  JSObjectSetProperty(context, global, JSStringRef propertyName, example, JSPropertyAttributes attributes, NULL);

  [ [webView mainFrame] loadRequest:
    [NSURLRequest requestWithURL: [NSURL URLWithString:url] ]
  ];
}

@end</pre>
</div>

<H4><a name="Javascript_gtk">28.3.2.2 GTK</a></H4>


<p>There is general information about programming GTK at <a href="https://developer.gnome.org/gtk2/">GTK documentation</a> and in the <a href="https://developer.gnome.org/gtk-tutorial/">GTK tutorial</a>, and for Webkit there is a <a href="https://webkitgtk.org/reference/webkitgtk/stable/index.html">Webkit GTK+ API Reference</a>.</p>
<p>An integration of a native extension 'example' would look like this:</p>
<div class="code">
<pre>
#include &lt;gtk/gtk.h&gt;
#include &lt;webkit/webkit.h&gt;

extern bool example_initialize(JSGlobalContextRef context);

int main(int argc, char* argv[])
{
  // Initialize GTK+
  gtk_init(&amp;argc, &amp;argv);

  ...

  // Create a browser instance
  WebKitWebView *webView = WEBKIT_WEB_VIEW(webkit_web_view_new());
  WebFrame *webframe = webkit_web_view_get_main_frame(webView);
  JSGlobalContextRef context = webkit_web_frame_get_global_context(webFrame);
  JSObjectRef global = JSContextGetGlobalObject(context);

  JSObjectRef exampleModule;
  example_initialize(context, &amp;exampleModule);
  JSStringRef jsName = JSStringCreateWithUTF8CString("example");
  JSObjectSetProperty(context, global, jsName, exampleModule, kJSPropertyAttributeReadOnly, NULL);
  JSStringRelease(jsName);

  ...

  // Load a web page into the browser instance
  webkit_web_view_load_uri(webView, "https://www.webkitgtk.org/");

  ...

  // Run the main GTK+ event loop
  gtk_main();

  return 0;
}</pre>
</div>

<H3><a name="Javascript_applications_webkit">28.3.3 Creating Applications with node-webkit</a></H3>


<p>To get started with <code>node-webkit</code> there is a very informative set of <a href="https://github.com/rogerwang/node-webkit/wiki">wiki pages</a>.</p>
<p>Similar to <code>node.js</code>, <code>node-webkit</code> is started from command line within a <code>node.js</code> project directory.
Native extensions are created in the very same way as for <code>node.js</code>, except that a customized <code>gyp</code> derivate has to be used: <a href="https://github.com/rogerwang/nw-gyp">nw-gyp</a>.
</p>

<p>
A simple example would have the following structure:
</p>

<div class="code">
<pre>
- package.json
- app.html
- app.js
- node_modules
  / example
  ... (as known from node.js)
</pre>
</div>

<p>
The configuration file essentially conforms to <code>node.js</code> syntax.
It has some extras to configure <code>node-webkit</code>. See the <a href="https://github.com/rogerwang/node-webkit/wiki/Manifest-format">Manifest</a> specification for more details.
</p>

<p>
<code>package.json</code>:
</p>
<div class="code">
<pre>
{
  "name": "example",
  "main": "app.html",
  "window": {
    "show": true,
    "width": 800,
    "height": 600
  }
}</pre>
</div>

<p>
The <code>'main'</code> property of <code>package.json</code> specifies a web-page to be rendered in
the main window.</p>

<p>
<code>app.html</code>:
</p>

<div class="code">
<pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="app.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      The greatest common divisor of
      &lt;span id="x"&gt;&lt;/span&gt; and
      &lt;span id="y"&gt;&lt;/span&gt; is
      &lt;span id="z"&gt;&lt;/span&gt;.
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
</div>

<p>
As known from <code>node.js</code> one can use <code>require</code> to load javascript modules.
Additionally, <code>node-webkit</code> provides an API that allows manipulating the window's menu,
open new windows, and many more things.
</p>

<p>
<code>app.js</code>:
</p>

<div class="code">
<pre>window.onload = function() {
  var example = require("example");
  var x = 18;
  var y = 24;
  var z = example.gcd(x, y);
  document.querySelector('#x').innerHTML = x;
  document.querySelector('#y').innerHTML = y;
  document.querySelector('#z').innerHTML = z;
};</pre>
</div>

<H2><a name="Javascript_examples">28.4 Examples</a></H2>


<p>Some basic examples are shown here in more detail.</p>

<H3><a name="Javascript_simple_example">28.4.1 Simple</a></H3>


<p>The common example <code>simple</code> looks like this:</p>
<div class="code">
<pre>
/* File : example.i */
%module example

%inline %{
extern int    gcd(int x, int y);
extern double Foo;
%}</pre>
</div>
<p>To make this available as a node extension a <code>binding.gyp</code> has to be created:</p>
<div class="code">
<pre>
{
  "targets": [
    {
      "target_name": "example",
      "sources": [ "example.cxx", "example_wrap.cxx" ]
    }
  ]
}</pre>
</div>
<p>Then <code>node-gyp</code> is used to build the extension:</p>
<div class="shell">
<pre>
$ node-gyp configure build</pre>
</div>
<p>From a 'nodejs` application the extension would be used like this:</p>
<div class="code">
<pre>
// import the extension via require
var example = require("./build/Release/example");

// calling the global method
var x = 42;
var y = 105;
var g = example.gcd(x, y);

// Accessing the global variable
var f = example.Foo;
example.Foo = 3.1415926;</pre>
</div>
<p>First the module <code>example</code> is loaded from the previously built extension. Global methods and variables are available in the scope of the module.</p>

<p><b>Note</b>: ECMAScript 5, the currently implemented Javascript standard, does not have modules. <code>node.js</code> and other implementations provide this mechanism defined by the <a href="https://wiki.commonjs.org/wiki/CommonJS">CommonJS</a> group. For browsers this is provided by <a href="https://browserify.org">Browserify</a>, for instance.</p>

<H3><a name="Javascript_class_example">28.4.2 Class</a></H3>


<p>The common example <code>class</code> defines three classes, <code>Shape</code>, <code>Circle</code>, and <code>Square</code>:</p>
<div class="code">
<pre>
class Shape {
public:
  Shape() {
    nshapes++;
  }
  virtual ~Shape() {
    nshapes--;
  }
  double  x, y;
  void    move(double dx, double dy);
  virtual double area(void) = 0;
  virtual double perimeter(void) = 0;
  static  int nshapes;
};

class Circle : public Shape {
private:
  double radius;
public:
  Circle(double r) : radius(r) { }
  virtual double area(void);
  virtual double perimeter(void);
};

class Square : public Shape {
private:
  double width;
public:
  Square(double w) : width(w) { }
  virtual double area(void);
  virtual double perimeter(void);
};</pre>
</div>
<p><code>Circle</code> and <code>Square</code> inherit from <code>Shape</code>. <code>Shape</code> has a static variable <code>nshapes</code>, a function <code>move</code> that can't be overridden (non-virtual), and two abstract functions <code>area</code> and <code>perimeter</code> (pure virtual) that must be overridden by the sub-classes.</p>
<p>A <code>nodejs</code> extension is built the same way as for the <code>simple</code> example.</p>
<p>In Javascript it can be used as follows:</p>
<div class="code">
<pre>
var example = require("./build/Release/example");

// local aliases for convenience
var Shape = example.Shape;
var Circle = example.Circle;
var Square = example.Square;

// creating new instances using the 'new' operator
var c = new Circle(10);
var s = new Square(10);

// accessing a static member
Shape.nshapes;

// accessing member variables
c.x = 20;
c.y = 30;
s.x = -10;
s.y = 5;

// calling some methods
c.area();
c.perimeter();
s.area();
s.perimeter();

// instantiation of Shape is not permitted
new Shape();</pre>
</div>
<p>Running these commands in an interactive node shell results in the following output:</p>
<div class="shell">
<pre>
$ node -i
&amp; var example = require("./build/Release/example");
undefined
&amp; var Shape = example.Shape;
undefined
&amp; var Circle = example.Circle;
undefined
&amp; var Square = example.Square;
undefined
&amp; var c = new Circle(10);
undefined
&amp; var s = new Square(10);
undefined
&amp; Shape.nshapes;
2
&amp; c.x = 20;
20
&amp; c.y = 30;
30
&amp; s.x = -10;
-10
&amp; s.y = 5;
5
&amp; c.area();
314.1592653589793
&amp; c.perimeter();
62.83185307179586
&amp; s.area();
100
&amp; s.perimeter();
40
&amp; c.move(40, 40)
undefined
&amp; c.x
60
&amp; c.y
70
&amp; new Shape()
Error: Class Shape can not be instantiated
at repl:1:2
at REPLServer.self.eval (repl.js:110:21)
at Interface.&lt;anonymous&gt; (repl.js:239:12)
at Interface.EventEmitter.emit (events.js:95:17)
at Interface._onLine (readline.js:202:10)
at Interface._line (readline.js:531:8)
at Interface._ttyWrite (readline.js:760:14)
at ReadStream.onkeypress (readline.js:99:10)
at ReadStream.EventEmitter.emit (events.js:98:17)
at emitKey (readline.js:1095:12)</pre>
</div>
<p>
<b>Note</b>: In ECMAScript 5 there is no concept for classes. Instead each function can be used as a constructor function which is executed by the 'new' operator. Furthermore, during construction the key property <code>prototype</code> of the constructor function is used to attach a prototype instance to the created object. A prototype is essentially an object itself that is the first-class delegate of a class used whenever the access to a property of an object fails. The very same prototype instance is shared among all instances of one type. Prototypal inheritance is explained in more detail on in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain</a>, for instance.
</p>

<H3><a name="Javascript_STL_example">28.4.3 STL Containers</a></H3>
<p>There are two strategies when dealing with STL containers:</p>
<ul>
  <li>
    <p>Wrap the C++ container to JavaScript - it is a C++ class that can be wrapped as any other class.
    <ul>
      <li><strong>+</strong> Avoids copying</li>
      <li><strong>-</strong> The interface won't have a native feel - the user will have to use <code>array.get(0)</code> instead of <code>array[0]</code> and native <code>Array</code> methods such as
        <code>map</code> won't be supported.</li>
    </ul>
    </p>
    <p>This works best when the container is large and it is expected to be reused across multiple calls.</p>
  </li>
  <li>
    <p>Use a typemap that converts the arguments at every call.
    <ul>
      <li><strong>+</strong> Native feel, methods can be called with a JavaScript array <code>method([1, 2, 3])</code></li>
      <li><strong>-</strong> The C++ container will have to be recreated at each call - values will be copied, pointers and references will remain pointing to the original object.</li>
      <li><strong>-</strong> The STL must contain default-constructible and copy-assignable objects.</li>
    </ul>
    </p>
    <p>This works best when the array is small and it is constructed ad-hoc from an anonymous JS array at each call - in this case there is no performance overhead at all.</p>
  </li>
</ul>

<p>The first method is available with every JavaScript generator, while the second is supported natively only by Node-API - but still can be manually implemented in a typemap for the others. Both methods work for both scalar types and class objects.</p>

<ul>
<li>
<p>Expose the C++ containers:</p>
<p>SWIG</p>
<div class="code">
<pre>
%include "std_vector.i"
// Refer to the section on C++ templates for this statement
%template (IntVector) std::vector&lt;int&gt;;
void consume(std::vector&lt;int&gt; const &amp;vec);
std::vector&lt;int&gt; produce();
</pre>
</div>
<p>JavaScript</p>
<div class="code">
<pre>
let vec = new IntVector;
vec.set(0, 10);
vec.set(1, 20);
consume(vec);
vec = produce();
let last = vec.get(vec.size() - 1);
</pre>
</div>
</li>

<li>
<p>Convert the C++ containers:</p>
<p>SWIG</p>
<div class="code">
<pre>
%include "std_vector.i"
// When using the  Node-API generator, std::vector and std::map
// will have INPUT, OUTPUT and RETURN typemaps

%apply(std::vector const &INPUT) { std::vector const &vec };
void consume(std::vector&lt;int&gt; const &amp;vec);

%apply(std::vector &OUTPUT) { std::vector &vec };
void produce1(std::vector&lt;int&gt;);

%apply(std::vector RETURN & ) { std::vector produce2 };
std::vector&lt;int&gt; &amp;produce2();
</pre>
</div>
<p>JavaScript</p>
<div class="code">
<pre>
consume([10, 20]);
let vec1 = produce1();
let vec2 = produce2();
let last1 = vec1[vec1.length - 1];
let last2 = vec2[vec2.length - 1];
</pre>
</div>
</li>
</ul>

<H3><a name="Javascript_Buffer_example">28.4.4 <code>Buffer</code> and <code>ArrayBuffer</code></a></H3>
<p>SWIG Node-API includes built-in typemaps for working with <code>Buffer</code> and <code>ArrayBuffer</code>. Note that the <code>Buffer</code> type is specific to Node.js and should be avoided when
  targeting browsers and WASM. In recent versions of Node.js <code>Buffer</code> is simply a wrapper around an <code>ArrayBuffer</code> and can be converted without copying the underlying data. The built-in typemaps reference special argument names - <code>buffer</code> and <code>arraybuffer</code> that can be applied to any other argument names - or simply to the raw types.</p>
<p>When dealing with raw buffers, three distinctive scenarios should be considered:</p>
<ul>
  <li>
    <p>The C/C++ function returns data by allocating a new buffer in pointers (or references) in its arguments. Such functions typically have arguments of this type:
      <code>(uint8_t **data, size_t *len)</code>.</p>
    <div class="code">
      <pre>
%include &lt;arraybuffer.i&gt;
%apply(void **arraybuffer_data, size_t *arraybuffer_len) { (uint8_t **data, size_t *len) };
</pre>
  </div>
  <p></p>
  <div class="code">
    <pre>
%include &lt;nodejs_buffer.i&gt;
%apply(void **buffer_data, size_t *buffer_len) { (uint8_t **data, size_t *len) };</pre>
  </div>
  <p>The wrapped function won't take any arguments and it will instead return the <code>Buffer</code>. The newly created <code>ArrayBuffer</code> or <code>Buffer</code> will contain a copy of the buffer. If the original buffer has to be freed, this is best accomplished in a <code>freearg</code> typemap using whatever method was used to allocate the buffer (<code>malloc</code>, <code>new</code> or <code>new[]</code>):</p>
  <div class="code">
    <pre>
  %typemap(freearg, noblock=1) (void **buffer_data, size_t *buffer_len) "free(*$1);";
  %typemap(freearg, noblock=1) (void **arraybuffer_data, size_t *arraybuffer_len) "free(*$1);";</pre>
</div>
  </li>
  <li>
    <p>The C/C++ function returns data by filling an existing buffer in its arguments. Such functions typically have arguments of this type:
      <code>(uint8_t *data, size_t len)</code>.</p>
  <div class="code">
      <pre>
%include &lt;arraybuffer.i&gt;
%apply(void *arraybuffer_data, size_t arraybuffer_len) { (uint8_t *data, size_t len) };</pre>
  </div>
  <p>In this case the two arguments will be replaced by a single <code>Buffer</code> argument and the C/C++ function will receive a pointer to its underlying data. The JavaScript object will be automatically protected from the GC for as long as the C/C++ functions runs. After its return, the data is no longer guaranteed to remain valid. This condition is also true for when the C/C++ functions is executed asynchronously from the main JavaScript code. This particular case is one of the few examples of incompatibilities between Node.js and the browser - be sure to check the WASM section for more details.</p>
  </li>
  <li>
    <p>The C++ function expect to receive a read-only buffer. Such functions typically have arguments of this type: <code>(const uint8_t *data, const size_t len)</code>.</p>
  <div class="code">
      <pre>
%include &lt;arraybuffer.i&gt;
%apply(const void *arraybuffer_data, const size_t arraybuffer_len) { (const uint8_t *data, const size_t len) };</pre>
  </div>
  <p></p>
  <div class="code">
    <pre>
%include &lt;nodejs_buffer.i&gt;
%apply(const void *buffer_data, const size_t buffer_len) { (const uint8_t *data, const size_t len) };</pre>
  </div>
  <p>In this case the two arguments will be replaced by a single <code>Buffer</code> argument and the C/C++ function will receive a pointer to its underlying data. The JavaScript object will be
    automatically protected from the GC for as long as the C/C++ functions runs. After its return, the data is no longer guaranteed to remain valid. This condition is also true for when the C/C++
    functions is executed asynchronously from the main JavaScript code.</p>
  </li>
</ul>

<H4><a name="Javascript_Buffer_example">28.4.4.1 Zero-copy <code>ArrayBuffer</code></a></H4>

<p>For applications requiring high efficiency or access to shared memory, a zero-copy <code>ArrayBuffer</code> can be used. This should be avoided when possible because it is error-prone and it is not compatible with WASM or some alternative Node-API implementations which define <a href="https://github.com/nodejs/node-addon-api/blob/main/doc/external_buffer.md"><code>NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</code></a> such as Electron.</p>

<p>A typemap that constructs a JS <code>ArrayBuffer</code> object around an existing memory buffer can be written as follows:</p>

  <div class="code">
    <pre>
%typemap(in, numinputs=0) (void **static_data, size_t *static_len) ($*1_ltype temp_data, size_t temp_len) {
  $1 = &temp_data;
  $2 = &temp_len;
}
%typemap(argout) (void **static_data, size_t *static_len) {
  if (*$1 != SWIG_NULLPTR) {
    Napi::ArrayBuffer buf = Napi::ArrayBuffer::New(env, *$1, *$2);
    NAPI_CHECK_RESULT(buf.As<Napi::Value>(), $result);
  } else {
    $result = env.Null();
  }
}</pre>
</div>

<p>It is also possible to add a callback to be called when the object is garbage-collected, allowing to free the buffer:</p>
  <div class="code">
    <pre>
  %typemap(in, numinputs=0) (void **arraybuffer_data, size_t *arraybuffer_len) ($*1_ltype temp_data, size_t temp_len) {
    $1 = &temp_data;
    $2 = &temp_len;
  }
  %typemap(argout) (void **arraybuffer_data, size_t *arraybuffer_len) {
    if (*$1 != SWIG_NULLPTR) {
      Napi::ArrayBuffer buf = Napi::ArrayBuffer::New(env, *$1, *$2, [](Napi::Env env, void *data) {
        free(data);
      });
      NAPI_CHECK_RESULT(buf.As<Napi::Value>(), $result);
    } else {
      $result = env.Null();
    }
  }</pre>
  </div>
<H2><a name="Javascript_exceptions">28.5 Exceptions</a></H2>

<H3><a name="Javascript_jsc_exceptions">28.5.1 Handling Exceptions in JavascriptCore</a></H3>
<p>Applications with an embedded JavascriptCore should be able to present detailed exception messages that occur in the Javascript engine. Below is an example derived from code provided by Brian
        Barnes on how these exception details can be extracted.</p>
<div class="code">
        <pre>
void script_exception_to_string(JSContextRef js_context, JSValueRef exception_value_ref, char* return_error_string, int return_error_string_max_length)
{
  JSObjectRef exception_object;
  JSValueRef value_ref;
  JSStringRef jsstring_property_name = NULL;
  JSValueRef temporary_exception = NULL;
  JSStringRef js_return_string = NULL;
  size_t bytes_needed;
  char* c_result_string = NULL;
  exception_object = JSValueToObject(js_context, exception_value_ref, NULL);

  /* source url */
  strcpy(return_error_string, &quot;[&quot;);
  jsstring_property_name = JSStringCreateWithUTF8CString(&quot;sourceURL&quot;);
  value_ref = JSObjectGetProperty(js_context, exception_object, jsstring_property_name, &amp;temporary_exception);
  JSStringRelease(jsstring_property_name);
  js_return_string = JSValueToStringCopy(js_context, value_ref, NULL);
  bytes_needed = JSStringGetMaximumUTF8CStringSize(js_return_string);
  c_result_string = (char*)calloc(bytes_needed, sizeof(char));
  JSStringGetUTF8CString(js_return_string, c_result_string, bytes_needed);
  JSStringRelease(js_return_string);
  strncat(return_error_string, c_result_string, return_error_string_max_length-1);
  free(c_result_string);

  strncat(return_error_string, &quot;:&quot;, return_error_string_max_length-1);

  /* line number */

  jsstring_property_name = JSStringCreateWithUTF8CString(&quot;line&quot;);
  value_ref = JSObjectGetProperty(js_context, exception_object, jsstring_property_name, &amp;temporary_exception);
  JSStringRelease(jsstring_property_name);
  js_return_string = JSValueToStringCopy(js_context, value_ref, NULL);
  bytes_needed = JSStringGetMaximumUTF8CStringSize(js_return_string);
  c_result_string = (char*)calloc(bytes_needed, sizeof(char));
  JSStringGetUTF8CString(js_return_string, c_result_string, bytes_needed);
  JSStringRelease(js_return_string);
  strncat(return_error_string, c_result_string, return_error_string_max_length-1);
  free(c_result_string);

  strncat(return_error_string, &quot;]&quot;, return_error_string_max_length-1);

  /* error message */

  jsstring_property_name = JSStringCreateWithUTF8CString(&quot;message&quot;);
  value_ref = JSObjectGetProperty(js_context, exception_object, jsstring_property_name, &amp;temporary_exception);
  JSStringRelease(jsstring_property_name);
  if(NULL == value_ref)
  {
    strncat(return_error_string, &quot;Unknown Error&quot;, return_error_string_max_length-1);
  }
  else
  {
    js_return_string = JSValueToStringCopy(js_context, value_ref, NULL);
    bytes_needed = JSStringGetMaximumUTF8CStringSize(js_return_string);
    c_result_string = (char*)calloc(bytes_needed, sizeof(char));
    JSStringGetUTF8CString(js_return_string, c_result_string, bytes_needed);
    JSStringRelease(js_return_string);
    strncat(return_error_string, c_result_string, return_error_string_max_length-1);
    free(c_result_string);
  }
}</pre>
</div>
<p>It would be used in the following way:</p>
<div class="code">
        <pre>
if(js_exception)
{
  char return_error_string[256];
  script_exception_to_string(js_context, js_exception, return_error_string, 256);
  printf("Compile error is %s", return_error_string);
}</pre>
</div>
<H3><a name="Javascript_napi_exceptions">28.5.2 Handling Exceptions in Node-API</a></H3>
<p>Node-API is the only generator that provides fully automatic conversion of C++ exceptions to JavaScript exceptions when building with C++ exceptions enabled in <code>binding.gyp</code>.</p>
<p>By default <code>node-gyp</code> builds with exceptions disabled and does so by tweaking a number of compiler options. The <code>node-addon-api</code> npm package includes a file that contains all the options needed to enable exceptions across the three officially supported compilers - g++, clang and MSVC.
<p><strong>It is highly recommended to enable exceptions using this file, especially when using MSVC which, unless the right options and macros are used, will happily produce a mostly working binary with some very subtle memory allocation/alignement errors.</strong></p>
<div class="code">
        <pre>
  'target_defaults': {
    'dependencies': [
      '&lt;!@(node -p "require(\'node-addon-api\').targets"):node_addon_api_except'
    ]
  }
</pre>
</div>
<p>In this case, nothing else is needed for the C++ exceptions to be passed to JavaScript.</p>
<p>Support for building Node-API modules without enabling C++ exceptions (<code>-fno-exceptions</code> compiler option) is currently incomplete and not unit tested.</p>

<H2><a name="Javascript_async">28.6 Asynchronous Execution</a></H2>
<p>The Node-API generator supports generating asynchronous wrappers. This feature is tightly linked to Node.js and libuv and mimics the semantics of the built-in class library. An asynchronous version of a function parses its arguments on the main thread and then queues the execution of the underlying C/C++ method in one of the existing background threads of the libuv pool. It then returns a <code>Promise</code> that resolves or rejects with the return value of the C/C++ function. The JavaScript code can continue its execution while the operation is running. This also allows launching multiple parallel instances of the C/C++ methods when these are reentrant. Otherwise, special locking must be implemented. By default, Node.js launches 4 worker threads which are also used by the internal class library for performing asynchonous file I/O (ie <code>fs.readFile()</code>). This behaviour can be adjusted via the environment variable <code>UV_THREADPOOL_SIZE</code>. For best results, this should be equal to the number of physical CPU cores.</p>

<p>Generation of asynchronous wrappers can be globally enabled from the CLI by passing <code>-async</code> option or by using <code>%feature</code>:</p>
<div class="code">
<pre>
// Generate sync wrappers with the suffix Sync
%feature("sync", "Sync");
// Generate async wrappers with the suffix Async
%feature("async", "Async");
// or generate async wrappers without suffix (this is the Node.js built-in class library convention)
%feature("async", "1");
// eventually, do not generate an async version for Klass::alwaysSync()
%feature("async", "0") Klass::alwaysSync
</pre>
</div>
        
<p>By default, only synchronous wrappers are generated. Only global functions and class methods can be asynchronous. Constructors, getters and setters are always synchronous.</p>

<p>An asynchronous wrapper is executed in three distinct steps:
<ul>
<li>Synchronous parsing of the input arguments on the main thread with V8 access - which includes the <code>in</code> and <code>check</code> typemaps</li>
<li>Asynchronous execution of the C/C++ function in a worker thread without access to V8 - this means that all underlying C/C++ objects must be unwrapped beforehand</li>
<li>Synchronous generation of the returned values on the main thread with V8 access - which include the <code>out</code> and <code>argout</code> typemaps</li>
</ul>
<code>Examples/javascript/async/native_async.i</code> contains an example of a hand-written async wrapper included with <code>%native</code>.
</p>

<H3><a name="Javascript_async_persistence">28.6.1 Persistence</a></H3>

<p>Asynchronous wrappers must manage persistence of the objects they will access. Consider the following example:</p>
<div class="code">
<pre>
function fn() {
  let obj = new asyncObj();  // This is a SWIG wrapped object
  obj.asyncMethod().then((r) => console.log(r));
}
</pre>
</div>
<p><code>fn()</code> will potentially exit before the asynchronous operation has completed. There is nothing guaranteeing that <code>obj</code> won't be collected by the GC right after the synchronous parsing of the input arguments of <code>asyncMethod()</code> - as this is the last reference to the JS object. Destroying the JS object will also destroy the underlying wrapped C/C++ object. In order to prevent this, an asynchronous wrapper must acquire persistent references to all objects that it will access. Persistence is fully automatic, SWIG will generate a <code>SWIG_Persist</code> method in all asynchronous tasklets that will acquire persistent references to all objects present in the input arguments of the function for the duration of the asynchronous execution.
</p>

<H3><a name="Javascript_async_locking">28.6.2 Locking</a></H3>

<p>
Asynchornous wrappers allow access to concurrent programming, meaning that multiple instances of the same method on the same object can potentially be running at the same time. Whether this is supported or not, and under what conditions, will depend on the wrapped C/C++ code. Most of the time, some sort of locking mecanism will have to be provided. SWIG supports an additional typemap, specific to Node-API async mode, <code>lock</code> which allows to register locking primitives for a given object. The locking primitives must be two lambdas without arguments that will be executed in the background thread without being allowed to access V8. Additionally, all C/C++ objects wrapped by SWIG now contain a mutex that can be used to implement locking. <code>javascriptasync.swg</code> contains a default implementation that automatically locks all wrapped objects. When wrapping objects that support natively being accessed simultaneously from multiple threads - because they are read-only or becase they implement their own synchronisation - these typemaps can be overriden with empty ones for no locking at all, or with a custom locking implementation. 
</p>
<p>
Locking must be enabled with <code>%feature</code>:
<div class="code">
<pre>
%feature("async:locking", "1");
</pre>
</div>
<p>
This will enable the inclusion of the async locking typemaps in both synchronous and asynchronous methods.
</p>

<p>In order to avoid dead-locking, the lambdas from the <code>lock</code> typemap are always executed in the same order for the same objects. This means that both <code>fn(a, b)</code> and <code>fn(b, a)</code> will lock <code>a</code> and <code>b</code> in the same order.</p>

<p>Every object type that should be locked has to have a <code>lock</code> typemap. There is a built-in default one that applies to all arguments called <code>LOCK</code>. It uses a mutex included in every SWIG proxy and works for all <code>struct</code>s and <code>class</code>es:</p>

<div class="code">
<pre>
%feature("async:locking", "1");

// Apply locking to all objects of type NonReentrantClass
%apply SWIGTYPE  LOCK {NonReentrantClass};
%apply SWIGTYPE *LOCK {NonReentrantClass *};
%apply SWIGTYPE &LOCK {NonReentrantClass &};

// Apply locking to all objects
%apply SWIGTYPE  LOCK {SWIGTYPE};
%apply SWIGTYPE *LOCK {SWIGTYPE *};
%apply SWIGTYPE &LOCK {SWIGTYPE &};
</pre>
</div>

<p>Locking can also be enabled or disabled on specific classes or specific methods:</p>

<div class="code">
<pre>
%feature("async:locking", "1");
%feature("async:locking", "0") Klass:UnsafeMethod;
</pre>
</div>

<p>When locking is disabled for a specific class, this means that all of its methods won't apply the <code>lock</code> typemaps at all. This is different from specifying an empty <code>lock</code> typemap for a specific class, in which case all wrappers won't apply locking only for this class. Here is an example:</p>

<div class="code">
<pre>
%feature("async:locking", "1");
%apply SWIGTYPE *LOCK {SWIGTYPE *};
%apply SWIGTYPE &LOCK {SWIGTYPE &};
%feature("async:locking", "0") UnsafeClass;
%typemap(lock) ReadonlyClass *, ReadonlyClass & "";
</pre>
</div>

<p>In this example, all methods of <code>UnsafeClass</code> won't apply any locking - for any type of argument. Methods of other classes will still apply locking to objects of <code>UnsafeClass</code>. On the other side, objects of <code>ReadonlyClass</code> will never be locked - when calling its own methods or when using such an object as an argument in another function.</p>

<p>The built-in locking has only one major drawback - it locks the SWIG proxy instead of the underlying object. This means that it is not compatible with typemaps that create multiple proxies for one object - such as the <code>DISOWN</code> typemaps or typemaps that clear <code>SWIG_POINTER_OWN</code></p>.

<H4><a name="Javascript_async_sync_locking">28.6.2.1 Creating Wrappers that Support Mixing Synchronous and Asynchronous Execution</H3>

<p>Special care must be taken when designing a wrapper that supports mixing of synchronous and asynchronous access. In this case one must never synchronously access objects that have been locked by an asynchronous operation. Trying to lock such object will result synchronous blocking of the event loop, effectively freezing the main thread - and the program - until the asynchronous operation completes. This is something that should be made clear to the end user of the wrapper. For example: </p>
<div class="code">
<pre>
const obj = new SwigObj(); // Create a new wrapped object that has locking enabled
const p = obj.doAsync();   // Launch a background asynchronous operation without await
const x = obj.x;           // Use a getter to access a member
</pre>
</div>
<p>
If locking for <code>SwigObj</code> is enabled, the last operation will have to lock <code>obj</code> - which has already been locked by the background operation. This will effectively block the main thread until the background operation completes. This can cause network buffer overflows in server code and UI freezing in desktop applications.
</p>

<H4><a name="Javascript_async_locking_starvation">28.6.2.2 Avoiding Thread Starvation</H3>

<p>
Another potential weakness of the async framework is thread starvation due to the limited number of threads in the thread pool. With 4 threads, if an end user program launches 4 operations on the same object - then all 4 threads will pick one of them - and then they will sequentially wait for the object to become available - locking out other operations that could have executed in parallel. Asynchronous operations are not preemptible. This weakness is inherent to the Node.js asynchronous framework and does not have an easy workaround. For example, in order to partially alleviate the starvation problem, the internal <code>fs.readFile()</code> method schedules its work in small 64Kb chunks to allow other tasks to run. This problem can also be partially alleviated by simply raising the number of threads in the pool.
</p>

<H4><a name="Javascript_async_shared_locking">28.6.2.3 Custom Locking Example</H3>

<p>Suppose we have a <code>Klass</code> that natively supports being called from multiple threads with complex locking semantics. We have to call <code>Klass::rolock()</code> to obtain a shared lock and <code>Klass::wrlock()</code> to obtain an exclusive lock. Methods that expect a shared lock have their arguments called <code>inp</code> and methods that expect an exclusive lock have their arguments called <code>out</code>. Here are two example typemaps that implement these semantics:</p>

<div class="code">
<pre>
%typemap(lock) Klass *inp, Klass &inp {
  // lock typemaps run after in and check typemaps, so these cannot fail
  // we already know that $input is an object of the correct type
  Klass *ptr;
  SWIG_ConvertPtr($input, (void**) &ptr, $1_descriptor, 0):
  // check if the object is not present twice in the arguments, ie fn(a, a)
  if (SWIG_locks.count(ptr) == 0) {
    // SWIG will use ptr as value for sorting (this is the dead-lock prevention algorithm)
    SWIG_locks.insert({reinterpret_cast&lt;void*&gt;(ptr), {
      // These lambdas will potentially run in a different thread
      // and they are not allowed to access V8 data
      [ptr](){ptr->rolock();},
      [ptr](){ptr->rounlock();}
    }});
  }
}

%typemap(lock) Klass *out, Klass &out {
  Klass *ptr;
  SWIG_ConvertPtr($input, (void**) &ptr, $1_descriptor, 0):
  if (SWIG_locks.count(ptr) == 0) {
    SWIG_locks.insert({reinterpret_cast&lt;void*&gt;(ptr), {
      [ptr](){ptr->wrlock();},
      [ptr](){ptr->wrunlock();}
    }});
  }
}
</pre>
</div>

<p><code>SWIG_locks</code> is the list of locks that have to be acquired for the operation. SWIG will take care of acquiring them in the correct order. Each lock consists of a unique identifier of type <code>void *</code> and two lambdas used for locking and unlocking.</p>

<H3><a name="Javascript_async_reject">28.6.3 Rejecting a <code>Promise</code> from a Typemap</H3>

<p>The usual Node.js convention is that functions that return a <code>Promise</code> should never throw synchronously, because this forces the end user to catch eventual errors in two distrinct ways. Throwing a C++ exception in a wrapped function will automatically result in a rejected <code>Promise</code>.</p>
  
<p>However SWIG-generated wrappers will still throw in <code>in</code> typemaps when a function is called with arguments that do not match its signature. As this should always be a critical error, it is not expected that a program will need to handle it at runtime.</p>

<p>On the other hand, when failing a <code>check</code> typemap, SWIG will automatically reject or throw depending on the type of the wrapper:</p>

<div class="code">
<pre>
// Automatically throw or reject depending
// on the type of the wrapper (sync/async)
%typemap(check) int positive {
  if ($1 <= 0) SWIG_exception_fail(SWIG_ValueError, "must be positive");
}
</pre>
</div>

<H2><a name="Typescript">28.7 Typescript</a></H2>

<p>SWIG can automatically generate TypeScript declarations - <code>.d.ts</code> files - so that the generated wrappers can be used from TypeScript with full type information. TypeScript support is enabled with the <code>-typescript</code> command line option. This will have the effect of producing an additional file with the module name and a <code>.d.ts</code> extension in the output directory. TypeScript can be used with all JavaScript engines. </p>

<p>When TypeScript is enabled, SWIG defines an additional macro, <code>SWIGTYPESCRIPT</code>, that can be used for conditional compilation.</p>

<p>Enabling TypeScript adds two additional typemaps that work in reverse compared to most other typemaps in SWIG - as they identify the TypeScript type from the C/C++ type.</p>

<ul>
<li>
<p>The <code>ts</code> typemap is used to specify the TypeScript type that will be used for an argument or for the return value of a function with the given C/C++ type. For example the buil-in TypeScript typemaps contain:</p>
<div class="code">
<pre>
%typemap(ts) char*, std::string, std::string *, std::string &   "string";
%typemap(ts) bool                                               "boolean";
%typemap(ts) float, double                                      "number";
</pre>
</div>
<p>
All valid TypeScript type manipulations can be used in the typemap - including generics, unions, intersection or even <code>infer</code>.</p>
</li>
<li>
<p>The <code>tsout</code> typemap modifies the return type of a function that has an argument of the specified type. Its main use is as a counterpart to an <code>argout</code> typemap that has transformed an argument into a return value. For example, this built-in Node-API TypeScript typemaps contain:</p>

<div class="code">
<pre>
%typemap(argout) (void **buffer_data, size_t *buffer_len) {
  // code to transform buffer_data / buffer_len arguments into a returned value
}
%typemap(tsout)  (void **buffer_data, size_t *buffer_len) "Buffer";
</pre>
</div>
</li>
</ul>

<H2><a name="Javascript_WASM">28.8 Compiling to WASM</a></H2>

<H3><a name="Javascript_WASM_intro">28.8.1 Introduction</a></H3>

<p>WASM is a standard for a virtual machine that runs a low-level bytecode and it is well-supported by most modern browsers and Node.js. It allows to run existing C/C++ code for POSIX - generally the work to port an existing POSIX-compatible project to WASM should be expected to be similar to the work for porting a Linux project to macOS. WASM inherits from a project called <code>asm.js</code> which allowed to interpret x86 assembler. JavaScript engines with WASM support implement this virtual machine directly in the engine itself for an increased performance.</p>
<p>The various data, text, heap and stack memory mappings of a WASM subroutines are stored in JavaScript <code>ArrayBuffer</code>s. WASM code remains subject to all the security restrictions of the underlying JavaScript engine. In particular, using multi-threading in browsers requires enabling <a href="https://web.dev/articles/coop-coep">COOP/COEP</a> as it relies on creating memory mappings in <code>SharedArrayBuffer</code>s.</p>

<p>Although the WASM virtual machines itself is well-specified, its environment ABI is not part of the standard. Currently, there are two competing ABIs for interacting with WASM code - the older de facto standard imposed by the <code>emscripten</code> compiler in which a WASM binary consists of a WASM blob and a generated JavaScript wrapper, and the newer official industry standard called WASI which specifies a common ABI interface. WASI is supported by recent versions of the <code>clang</code> compiler.</p>

<H3><a name="Javascript_WASM_building">28.8.2 Building SWIG Node-API generated wrappers to WASM</a></H3>

<p>Code produced by the Node-API generator, including the asynchronous wrappers, is unit-tested to be fully compatible with the <code><a href="https://emnapi-docs.vercel.app/">emnapi</a></code> project. This means that wrappers produced by SWIG can be built to WASM by modifying only the build process.</p>

<p>At the moment only <code>emscripten</code> is supported. Support for <code>WASI</code>-compliant platforms is also planned. It should be noted that currently <code>WASI</code> is far less complete and mature than <code>emscripten</code> with the most notable missing feature being support for C++ exceptions.</p>

<p>When using <code>emscripten</code>, code produced by the Node-API generator should be built with the following options.</p>

<ul>

<li><p>Compiler settings</p>
<div class="code">
<pre>
<em># required by SWIG Node-API (although supported in theory,
# building w/o exceptions is still not unit tested at the moment)</em>
-fexceptions

<em># the emnapi glue code that allows C++ to parse JavaScript values
# after installing emnapi (npm install emnapi)</em>
-I <em>[the output of `node -p "require('emnapi').include"`]</em>
</pre>
</div>

<li><p>Library / Additional sources</p>
<ul>
<li><p>Option 1: include the additional source files listed by the output of <code>node -p "require('emnapi').sources"</code></p></li>
<div class="code">
<pre>
emnapi/packages/emnapi/src/js_native_api.c
emnapi/packages/emnapi/src/node_api.c
emnapi/packages/emnapi/src/async_cleanup_hook.c
emnapi/packages/emnapi/src/async_context.c
emnapi/packages/emnapi/src/async_work.c
emnapi/packages/emnapi/src/threadsafe_function.c
emnapi/packages/emnapi/src/uv/uv-common.c
emnapi/packages/emnapi/src/uv/threadpool.c
emnapi/packages/emnapi/src/uv/unix/loop.c
emnapi/packages/emnapi/src/uv/unix/thread.c
emnapi/packages/emnapi/src/uv/unix/async.c
emnapi/packages/emnapi/src/uv/unix/core.c
</pre>
</div>
<li><p>Option 2: link with the precompiled static library <code>emnapi.a</code> (no async) or <code>emnapi-mt.a</code> (w/ async)</p></li>
<div class="code">
<pre>
-lemnapi -L./node_modules/emnapi/lib/wasm32-emscripten
</pre>
</div>
</ul>

<li><p>Linker settings</p>
<div class="code">
<pre>
<em># the emnapi glue code that allows C++ to parse JavaScript values
# after installing emnapi (npm install emnapi)</em>
--js-library= <em>[the output of `node -p "require('emnapi').js_library"`</em>

<em># highly recommended, otherwise the allocated memory will be fixed in the beginning</em>
-sALLOW_MEMORY_GROWTH=1

<em># required by emnapi</em>
-sEXPORTED_FUNCTIONS=["_napi_register_wasm_v1","_malloc","_free"]

<em># see above</em>
-sNO_DISABLE_EXCEPTION_CATCHING

<em># recommended, produces an ES6-compatible module for the emscripten JavaScript wrapper</em>
-sMODULARIZE=1

<em># required when producing ES6-compatible module</em>
-sEXPORT_NAME=<em>[module-name]</em>

<em># required by emnapi</em>
--bind
</pre>
</div>
</li>

<li><p>Additional compiler settings for multi-threading - allows the use of async wrappers but imposes COOP/COEP for browser use</p>
<div class="code">
<pre>
<em># By default, set the worker pool size to the same value
# as the default one in Node.js/libuv:</em>
-pthread -DEMNAPI_WORKER_POOL_SIZE=4
</pre>
</div>
</li>

<li><p>Additional linker settings for multi-threading</p>
<div class="code">
<pre>
<em># By default, set the worker pool size to the same value
# as the default one in Node.js/libuv:</em>
-pthread -DEMNAPI_WORKER_POOL_SIZE=4 -sPTHREAD_POOL_SIZE=4
</pre>
</div>
</li>

<li><p>Additional compiler settings for a debug build - these add extra checks and will enrich WASM stack-traces with function names</p>
<div class="code">
<pre>
-gsource-map
</pre>
</div>
</li>

<li><p>Additional linker settings for a debug build</p>
<div class="code">
<pre>
<em># Reduce ASSERTIONS to 1 if you have exceptions about missing integer truncation</em>
-gsource-map -sSAFE_HEAP=1 -sASSERTIONS=2 -sSTACK_OVERFLOW_CHECK=2
</pre>
</div>
</li>


</ul>

<H3><a name="Javascript_WASM_importing">28.8.3 Importing SWIG Node-API generated wrappers built to WASM</a></H3>

<p>The WASM specification imposes an asynchronous interface for Javascript code loading a WASM blob. As browsers are highly asynchronous, this is usually not a problem, but when importing a WASM module in Node.js, it must be <code>await</code>ed before it can be used. This means that WASM cannot be used in a fully synchronous Node.js program and it is best used in ECMAScript mode.</p>

<p>In order to import compiled module in Node.js, the following code snippet can be used:</p>

<div class="code">
<pre>
const emnapi = require('@emnapi/runtime');
module.exports = require('./build/Release/<em>[module-name]</em>')()
  .then((m) => m.emnapiInit({context: emnapi.getDefaultContext()}));
</pre>
</div>

<p>If using TypeScript with WASM, the generated typings will be compatible but it will be necessary to take into account that the whole API is now hidden behind a <code>Promise</code> - example for an <code>index.d.ts</code>:</p>

<div class="code">
<pre>
// Import the original SWIG-generated typings and re-export everything in a Promise
declare const <em>module_name</em>: Promise&lt;typeof import(&#39;<em>module_name</em>&#39;)&gt;;
export default <em>module_name</em>;
</pre>
</div>

<H3><a name="Javascript_WASM_async">28.8.4 Using asynchronous wrappers with WASM</code></a></H3>

<p>The WASM builds support using the same asynchonous wrappers as the native Node.js builds. This feature is provided by <code>emnapi</code> which re-implements the <code>libuv</code> API. Upon loading the WASM bundle, the <code>emnapi</code> runtime will spawn 4 threads (<em>this is the meaning of the compilation option</em>) that will use <code>SharedArrayBuffer</code>s to communicate with the WASM code in the main thread. When calling an asynchronous method, a WASM stub in the main thread will queue its arguments to be executed by a worker from the pool. All C++/WASM objects live in a <code>SharedArrayBuffer</code> accessible to all threads. This mimics the Node.js asynchronous model. The use of <code>SharedArrayBuffer</code> imposes the requirement that the web server hosting the web page supports <a href="https://web.dev/articles/coop-coep">COOP/COEP</a>. Trying to load a WASM bundle compiled for COOP/COEP from a web server that does not enable it, will fail. Currently there is no built-in mechanism to enable automatic fallback to a non-COOP/COEP build as this build won't have the same API.</p>

<p>If COOP/COEP is not an option, currently there are only two options:</p>
<ul>
  <li><p>Accept that C++/WASM methods will cause main thread latency and call everything synchronously - which will work well only if all C++ methods execute very fast</p></li>
  <li><p>Use <a href="https://github.com/GoogleChromeLabs/comlink">GoogleChromeLabs/comlink</a> to run the synchronous code in a worker - which will work well only if all C++ methods have long execution times since it will add significant overhead. Dpending on the API, this may require some form of custom serialization or proxying of the C++ objects</p></li>
</ul>

<p>If mixing both methods, it won't be possible to share C++/WASM objects between the main thread and the <code>comlink</code> worker as these will be stored in two separate <code>ArrayBuffer</code>s. in two separate isolates.</p>

<p>In the future, there might be a third option for I/O heavy code that will run the WASM code in the main thread, but it will behave as JavaScript asynchronous code for I/O - using <code>Asyncify</code>.</p>

<H3><a name="Javascript_WASM_differences">28.8.5 Incompatibilities between <code>node-addon-api</code> and <code>emnapi</code></a></H3>

<p>There are some minor incompatibilities between the two platforms, mostly pertaining to the fact that WASM uses a separate heap from JavaScript which places additional restrictions on using <code>ArrayBuffer</code> objects. These cannot always be transparently shared between JavaScript and C++ and must be copied. This is not a problem for functions that expect an <code>ArrayBuffer</code> as argument or that return a new <code>ArrayBuffer</code> as a result - in these cases <code>emnapi</code> will automatically handle the copying. However functions that expect an <code>ArrayBuffer</code> argument and modify it, will need an additional step for these modifications to be copied back to the JavaScript copy.</p>

<p>The built-in typemaps for handling a writable <code>ArrayBuffer</code> in <code>arraybuffer.i</code> takes this into account and can be used as an example for implementing similar typemaps.</p>

<H2><a name="Javascript_code_splitting">28.9 Code Spltting</a></H2>

<p>The JavaScript generator includes support for splitting the generated wrapper code into multiple compilation unit. This allows to greatly reduce the memory requirements, especially when using templated C++ code. At the moment only the Node-API generator supports it. Code splitting is enabled with the <code>-split</code> command-line option. In this mode, SWIG will produce a single header file and a number of C++ source files that include it. Each class will be placed a in a separate file and there will be one file with all the global functions.</p>

<p>As SWIG Node-API relies heavily on templating, the generated header file may appear very large - however since each compilation unit will instantiate only one template, this still allows to keep the compilation memory requirements as low as possible.</p>

<p>Code splitting imposes some additional restrictions on the C++ code embedded in the SWIG interface file. Code included in verbatim code blocks will be considered definitions and it will be placed in the header file. This means that this code must follow the rules for C/C++ header files and can no longer contain function bodies - unless these are marked <code>inline</code>. All variable declarations must be marked <code>extern</code>. Code that shall be included in the source files must be part of a <code>%wrapper</code> section - in this case it will be placed in one of the independant compilation units. As most of the time, a real-world interface file will contain mostly <code>#include</code> directives, this should not be of any concern. Nothing changes for code included as part of a typemap. When dealing with typemaps, SWIG will generate declarations in the header file and it will place the typemap bodies in one of the compilation units.</p>

<p>For example, in order to support code-splitting, the following code:</p>

<div class="code">
<pre>
%inline %{
const char *version = "1.0.0";
int add(int a, int b) { return a + b; }
%}
</pre>
</div>

<p>must become:</p>

<div class="code">
<pre>
%inline %{
extern const char *version;
int add(int a, int b);
%}

%wrapper %{
const char *version = "1.0.0";
int add(int a, int b) { return a + b; }
%}
</pre>
</div>


<H2><a name="Javascript_implementation">28.10 Implementation</a></H2>


<p>The Javascript Module implementation has taken a very different approach compared to other language modules in order to support different Javacript interpreters.</p>

<H3><a name="Javascript_source_code">28.10.1 Source Code</a></H3>


<p>The Javascript module is implemented in <code>Source/Modules/javascript.cxx</code>. It dispatches the code generation to a <code>JSEmitter</code> instance, <code>V8Emitter</code>, <code>JSCEmitter</code> or <code>NAPIEmitter</code>. Additionally there are some helpers: <code>Template</code>, for templated code generation, and <code>JSEmitterState</code>, which is used to manage state information during AST traversal. This rough map shall make it easier to find a way through this huge source file:</p>
<div class="code">
<pre>
// module wide defines

#define NAME "name"
...

// ###############################
// #  Helper class declarations

class JSEmitterState { ... };

class Template { ... };

// ###############################
// # JSEmitter declaration

class JSEmitter { ... };

// Emitter factory declarations

JSEmitter *swig_javascript_create_JSCEmitter();
JSEmitter *swig_javascript_create_V8Emitter();
JSEmitter *swig_javascript_create_NAPIEmitter();

// ###############################
// # Javascript module

// Javascript module declaration

class JAVASCRIPT:public Language { ... };

// Javascript module implementation

int JAVASCRIPT::functionWrapper(Node *n) { ... }
...

// Module factory implementation

static Language *new_swig_javascript() { ... }

extern "C" Language *swig_javascript(void) { ... }

// ###############################
// # JSEmitter base implementation

JSEmitter::JSEmitter() { ... }

Template JSEmitter::getTemplate(const String *name) { ... }
...

// ###############################
// # JSCEmitter

// JSCEmitter declaration

class JSCEmitter: public JSEmitter { ... };

// JSCEmitter implementation

JSCEmitter::JSCEmitter() { ... }

void JSCEmitter::marshalInputArgs(Node *n, ParmList *parms, Wrapper *wrapper, MarshallingMode mode, bool is_member, bool is_static) { ... }
...

// JSCEmitter factory

JSEmitter *swig_javascript_create_JSCEmitter() { ... }


// ###############################
// # V8Emitter

// V8Emitter declaration

class V8Emitter: public JSEmitter { ... };

// V8Emitter implementation

V8Emitter::V8Emitter() { ... }

int V8Emitter::initialize(Node *n) { ... }

// V8Emitter factory

JSEmitter *swig_javascript_create_V8Emitter() { ... }


// ###############################
// # Helper implementation (JSEmitterState, Template)

JSEmitterState::JSEmitterState() { ... }
...

Template::Template(const String *code_) { ... }
...</pre>
</div>

<H3><a name="Javascript_code_templates">28.10.2 Code Templates</a></H3>


<p>All generated code is created on the basis of code templates. The templates for <em>JavascriptCore</em> can be found in <code>Lib/javascript/jsc/javascriptcode.swg</code>, for <em>v8</em> in <code>Lib/javascript/v8/javascriptcode.swg</code> and for <em>Node-API</em> in <code>Lib/javascript/napi/javascriptcode.swg</code>.</p>
<p>To track the originating code template for generated code you can run</p>
<div class="shell">
<pre>
$ swig -javascript -jsc -debug-codetemplates</pre>
</div>
<p>which wraps generated code with a descriptive comment</p>
<div class="code">
<pre>
/* begin fragment("template_name") */

...generated code ...

/* end fragment("template_name") */</pre>
</div>
<p>The Template class is used like this:</p>
<div class="code">
<pre>
Template t_register = getTemplate("jsv8_register_static_variable");
t_register.replace("$jsparent", state.clazz(NAME_MANGLED))
    .replace("$jsname", state.variable(NAME))
    .replace("$jsgetter", state.variable(GETTER))
    .replace("$jssetter", state.variable(SETTER))
    .trim().
    print(f_init_static_wrappers);</pre>
</div>
<p>A code template is registered with the <em>JSEmitter</em> via <code>fragment(name, &quot;template&quot;)</code>, e.g., </p>
<div class="code">
<pre>
%fragment ("jsc_variable_declaration", "templates")
%{
  {"$jsname", $jsgetter, $jssetter, kJSPropertyAttributeNone},
%}</pre>
</div>
<p><code>Template</code> creates a copy of that string and <code>Template::replace</code> uses Swig's <code>Replaceall</code> to replace variables in the template. <code>Template::trim</code> can be used to eliminate leading and trailing whitespaces. <code>Template::print</code> is used to write the final template string to a Swig <code>DOH</code> (based on <code>Printv</code>). All methods allow chaining.</p>

<H3><a name="Javascript_emitter">28.10.3 Emitter</a></H3>


<p>The Javascript module delegates code generation to a <code>JSEmitter</code> instance. The following extract shows the essential interface:</p>
<div class="code">
<pre>
class JSEmitter {
  ...

  /**
   * Opens output files and temporary output DOHs.
   */
  virtual int initialize(Node *n);

  /**
   * Writes all collected code into the output file(s).
   */
  virtual int dump(Node *n) = 0;

  /**
   * Cleans up all open output DOHs.
   */
  virtual int close() = 0;

  ...

  /**
   * Invoked at the beginning of the classHandler.
   */
  virtual int enterClass(Node *);

  /**
   * Invoked at the end of the classHandler.
   */
  virtual int exitClass(Node *) {
    return SWIG_OK;
  }

  /**
   * Invoked at the beginning of the variableHandler.
   */
  virtual int enterVariable(Node *);

  /**
   * Invoked at the end of the variableHandler.
   */
  virtual int exitVariable(Node *) {
    return SWIG_OK;
  }

  /**
   * Invoked at the beginning of the functionHandler.
   */
  virtual int enterFunction(Node *);

  /**
   * Invoked at the end of the functionHandler.
   */
  virtual int exitFunction(Node *) {
    return SWIG_OK;
  }

  /**
   * Invoked by functionWrapper callback after call to Language::functionWrapper.
   */
  virtual int emitWrapperFunction(Node *n);

  /**
   * Invoked from constantWrapper after call to Language::constantWrapper.
   **/
  virtual int emitConstant(Node *n);

  /**
   * Registers a given code snippet for a given key name.
   *
   * This method is called by the fragmentDirective handler
   * of the JAVASCRIPT language module.
   **/
  int registerTemplate(const String *name, const String *code);

  /**
   * Retrieve the code template registered for a given name.
   */
  Template getTemplate(const String *name);

  State &amp;getState();

  ...

}</pre>
</div>
<p>The module calls <code>initialize</code>, <code>dump</code>, and <code>close</code> from within the <code>top</code> method:</p>
<div class="code">
<pre>
int JAVASCRIPT::top(Node *n) {
  emitter-&gt;initialize(n);

  Language::top(n);

  emitter-&gt;dump(n);
  emitter-&gt;close();

  return SWIG_OK;
}</pre>
</div>
<p>The methods <code>enterClass</code> and <code>exitClass</code> are called from within the <code>classHandler</code> method:</p>
<div class="code">
<pre>
int JAVASCRIPT::classHandler(Node *n) {

  emitter-&gt;enterClass(n);
  Language::classHandler(n);
  emitter-&gt;exitClass(n);

  return SWIG_OK;
}</pre>
</div>
<p>In <code>enterClass</code> the emitter stores state information that is necessary when processing class members. In <code>exitClass</code> the wrapper code for the whole class is generated.</p>

<H3><a name="Javascript_emitter_states">28.10.4 Emitter states</a></H3>


<p>For storing information during the AST traversal the emitter provides a <code>JSEmitterState</code> with different slots to store data representing the scopes global, class, function, and variable.</p>
<div class="code">
<pre>
class JSEmitterState {

public:

  JSEmitterState();

  ~JSEmitterState();

  DOH *global();

  DOH *global(const char* key, DOH *initial = 0);

  DOH *clazz(bool reset = false);

  DOH *clazz(const char* key, DOH *initial = 0);

  DOH *function(bool reset = false);

  DOH *function(const char* key, DOH *initial = 0);

  DOH *variable(bool reset = false);

  DOH *variable(const char* key, DOH *initial = 0);

  static int IsSet(DOH *val);

  ...
};</pre>
</div>
<p>When entering a scope, such as in <code>enterClass</code>, the corresponding state is reset and new data is stored:</p>
<div class="code">
<pre>
state.clazz(RESET);
state.clazz(NAME, Getattr(n, "sym:name"));</pre>
</div>
<p>State information can be retrieved using <code>state.clazz(NAME)</code> or with <code>Getattr</code> on <code>state.clazz()</code> which actually returns a <code>Hash</code> instance.</p>
</body>
</html>
