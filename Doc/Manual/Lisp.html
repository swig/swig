<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SWIG and Common Lisp</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body bgcolor="#ffffff">
<H1><a name="Lisp_nn1"></a>21 SWIG and Common Lisp</H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#Lisp_nn2">Allegro Common Lisp</a>
<li><a href="#Lisp_nn3">CLISP</a>
<ul>
<li><a href="#Lisp_nn4">Additional Commandline Options </a>
<li><a href="#Lisp_nn5">Details on CLISP bindings</a>
</ul>
<li><a href="#Lisp_nn6">UFFI </a>
</ul>
</div>
<!-- INDEX -->



<p>
      Common Lisp is a high-level, all-purpose, object-oriented,
      dynamic, functional programming language with long history. 
      Common Lisp is used in many fields, ranging from web development to
      finance, and also common in computer science education.
      There are more than 9 different implementations of common lisp which
      are available, all have different foreign function
      interfaces. SWIG currently supports only the Allegro Common
      Lisp, CLisp and UFFI foreign function interfaces. 
</p>
<H2><a name="Lisp_nn2"></a>21.1 Allegro Common Lisp</H2>


<p>
  Allegro Common Lisp support in SWIG has been updated to include
  support for both C and C++. You can read about the interface
  <a href="Allegrocl.html#Allegrocl_nn1">here</a>
</p>


<H2><a name="Lisp_nn3"></a>21.2 CLISP</H2>


<p>
<a href="http://clisp.cons.org">CLISP</a> is a feature-loaded
      implementation of common lisp which is portable across most of the
      operating system environments and hardware. CLISP includes an
      interpreter, a compiler, a debugger, CLOS, MOP, a foreign
      language interface, i18n, regular expressions, a socket
      interface, and more. An X11 interface is available through CLX,
      Garnet and CLUE/CLIO. Command line editing is provided by
      readline. CLISP runs Maxima, ACL2 and many other Common Lisp
      packages. <br/>

      To run the SWIG module of clisp requires very little effort, you
      just need to execute:

<div class="code"><pre>
swig -clispcl -module <i>module-name</i>   <i>file-name</i> 

</pre></div>

      Because of the high level nature of the CLISP FFI, the bindings
    generated by SWIG may not be absolutely correct, and you may need
    to modify them. The good thing is that you don't need to complex 
    interface file for the CLISP module. The CLISP module tries to
    produce code which is both human readable and easily modifyable.
</p>
<H3><a name="Lisp_nn4"></a>21.2.1 Additional Commandline Options </H3>


<p>
The following table list the additional commandline options available for the CLISP module. They can also be seen by using: 
</p>

<div class="code"><pre>
swig -clisp -help 
</pre></div>
<br/>
<table summary="CLISP specific options">
<tr>
<th>CLISP specific options</th>
</tr>

<tr>
<td>-extern-all</td>
<td>If this option is given then clisp definitions for all the functions<br/>
and global variables will be created otherwise only definitions for<br/>
	    externed functions and variables are created. 
</td>
</tr>

<tr>
<td>-generate-typedef</td>
<td>If this option is given then def-c-type will be used to generate<br/>
	    shortcuts according to the typedefs in the input.
</td>
</tr>

</table>

<H3><a name="Lisp_nn5"></a>21.2.2 Details on CLISP bindings</H3>


<p>
As mentioned earlier the CLISP bindings generated by SWIG may need
	some modifications. The clisp module creates a lisp file with
	the same name as the module name. This
	lisp file contains a 'defpackage' declaration, with the
	package name same as the module name. This package uses the
	'common-lisp' and 'ffi' packages. Also, package exports all
	the functions, structures and variables for which an ffi
	binding was generated.<br/>
     After generating the defpackage statement, the clisp module also
	sets the default language.

<div class="targetlang"><pre>
(defpackage :test
    (:use :common-lisp :ffi)
  (:export
   :make-bar
   :bar-x
   :bar-y
   :bar-a
   :bar-b
   :bar-z
   :bar-n
   :pointer_func
   :func123
   :make-cfunr
   :lispsort_double
   :test123))

(in-package :test)

(default-foreign-language :stdc)
</pre></div>
<p>
The ffi wrappers for functions and variables are generated as shown
      below. When functions have arguments of type "double * array",
      SWIG doesn't knows whether it is an 'out' argument or it is
      an array which will be passed, so SWIG plays it safe by
      declaring it as an '(array (ffi:c-ptr DOUBLE-FLOAT))'. For
      arguments of type "int **z[100]" where SWIG has more
      information, i.e., it knows that 'z' is an array of pointers to
      pointers of integers, SWIG defines it to be '(z (ffi:c-ptr
      (ffi:c-array (ffi:c-ptr (ffi:c-ptr ffi:int)) 100)))'  
</p>
<div class="code"><pre>
extern "C" {
int pointer_func(void (*ClosureFun)( void* _fun, void* _data, void* _evt ), int y);

int func123(div_t * x,int **z[100],int y[][1000][10]);

void lispsort_double (int n, double * array);

void test123(float x , double y);

}
</pre></div>
<div class="targetlang"><pre>
(ffi:def-call-out pointer_func
    (:name "pointer_func")
  (:arguments (ClosureFun (ffi:c-function (:arguments (arg0 (ffi:c-pointer NIL))
						      (arg1 (ffi:c-pointer NIL))
						      (arg2 (ffi:c-pointer NIL)))
					  (:return-type NIL)))
	      (y ffi:int))
  (:return-type ffi:int)
  (:library +library-name+))

(ffi:def-call-out func123
    (:name "func123")
  (:arguments (x (ffi:c-pointer div_t))
	      (z (ffi:c-ptr (ffi:c-array (ffi:c-ptr (ffi:c-ptr ffi:int)) 100)))
	      (y (ffi:c-ptr (ffi:c-ptr (ffi:c-array ffi:int (1000 10))))))
  (:return-type ffi:int)
  (:library +library-name+))


(ffi:def-call-out lispsort_double
    (:name "lispsort_double")
  (:arguments (n ffi:int)
	      (array (ffi:c-ptr DOUBLE-FLOAT)))
  (:return-type NIL)
  (:library +library-name+))

(ffi:def-call-out test123
    (:name "test")
  (:arguments (x SINGLE-FLOAT)
	      (y DOUBLE-FLOAT))
  (:return-type NIL)
  (:library +library-name+))

</pre></div>

<p>
The module also handles strutcures and #define constants as shown
      below. SWIG automatically adds the constructors and accessors
    created for the struct to the list of symbols exported by the
      package.
</p>
<div class="code"><pre>
struct bar {
    short x, y;
    char a, b;
    int *z[1000];
    struct bar * n;
};

#define max 1000
</pre></div>
<div class="targetlang"><pre>
(ffi:def-c-struct bar
    (x :type ffi:short)
  (y :type ffi:short)
  (a :type character)
  (b :type character)
  (z :type (ffi:c-array (ffi:c-ptr ffi:int) 1000))
  (n :type (ffi:c-pointer bar)))

(defconstant max 1000)

</pre></div>

<H2><a name="Lisp_nn6"></a>21.3 UFFI </H2>


<p>

</p>
</body>
</html>
