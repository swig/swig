<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SWIG and C as the target language</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body bgcolor="#FFFFFF">
<H1><a name="C"></a>36 SWIG and C as the target language</H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#C_overview">Overview</a>
<li><a href="#C_preliminaries">Preliminaries</a>
<ul>
<li><a href="#C_running_swig">Running SWIG</a>
<li><a href="#C_commandline">Command line options</a>
<li><a href="#C_dynamic">Compiling dynamic module</a>
<li><a href="#C_using_module">Using generated module</a>
</ul>
<li><a href="#C_basic_c_wrapping">Basic C wrapping</a>
<ul>
<li><a href="#C_functions">Functions</a>
<li><a href="#C_variables">Variables</a>
<li><a href="#C_enums">Enums</a>
</ul>
<li><a href="#C_basic_cpp_wrapping">Basic C++ wrapping</a>
<ul>
<li><a href="#C_classes">Classes</a>
</ul>
<li><a href="#C_exceptions">Exception handling</a>
</ul>
</div>
<!-- INDEX -->



<p>
This chapter describes SWIG's support for creating ANSI C wrappers. This module has a special purpose and thus is different from most other modules.
</p>

<p>
<b>NOTE:</b> this module is still under development.
</p>


<H2><a name="C_overview"></a>36.1 Overview</H2>


<p>
SWIG is normally used to provide access to C or C++ libraries from target languages such as scripting languages or languages running on a virtual machine. 
SWIG performs analysis of the input C/C++ library header files from which it generates further code. For most target languages this code consists of two layers; namely an intermediary C code layer and a set of language specific proxy classes and functions on top of the C code layer. 
We could also think of C as just another target language supported by SWIG.
The aim then is to generate a pure ANSI C interface to the input C or C++ library and hence the C target language module.
</p>

<p>
With wrapper interfaces generated by SWIG, it is easy to use the functionality of C++ libraries inside application code written in C. This module may also be useful to generate custom APIs for a library, to suit particular needs, e.g. to supply function calls with error checking or to implement a "design by contract".
</p>

<p>
Flattening C++ language constructs into a set of C-style functions obviously comes with many limitations and inconveniences. All data and functions become global. Manipulating objects requires explicit calls to special functions. We are losing the high level abstraction and have to work around it.
</p>

<H3>Known C++ Shortcomings in Generated C API:</H3>
<ul>
    <li>Namespaced global functions are not namespaced</li>
    <li>Enums with a context like class or namespace are broken</li>
    <li>Global variables are not supported</li>
    <li>Qualifiers are stripped</li>
</ul>
<H2><a name="C_preliminaries"></a>36.2 Preliminaries</H2>


<H3><a name="C_running_swig"></a>36.2.1 Running SWIG</H3>


<p>
Consider the following simple example. Suppose we have an interface file like:
</p>

<div class="code">
<pre>
/* File: example.i */
%module test
%{
#include "stuff.h"
%}
int fact(int n);
</pre>
</div>

<p>
To build a C module (C as the target language), run SWIG using the <tt>-c</tt> option :</p>

<div class="shell"><pre>
$ swig -c example.i
</pre></div>

<p>
The above assumes C as the input language. If the input language is C++ add the <tt>-c++</tt> option:
</p>

<div class="shell"><pre>
$ swig -c++ -c example.i
</pre></div>

<p>
Note that <tt>-c</tt> is the option specifying the <b>target</b> language and <tt>-c++</tt> controls what the <b>input</b> language is.
<p>

<p>
This will generate an <tt>example_wrap.c</tt> file or, in the latter case, <tt>example_wrap.cxx</tt> file, along with <tt>example_wrap.h</tt> (the same extension is used in both C and C++ cases for the last one). The names of the files are derived from the name of the input file by default, but can be changed using the <tt>-o</tt> and <tt>-oh</tt> options common to all language modules. 
</p>

<p>
The <tt>xxx_wrap.c</tt> file contains the wrapper functions, which perform the main functionality of SWIG: each of the wrappers translates the input arguments from C to C++, makes calls to the original functions and marshals C++ output back to C data. The <tt>xxx_wrap.h</tt> header file contains the declarations of these functions as well as global variables.
</p>

<H3><a name="C_commandline"></a>36.2.2 Command line options</H3>


<p>
The following table list the additional command line options available for the C module. They can also be seen by using: 
</p>

<div class="shell"><pre>
$ swig -c -help
</pre></div>

<table summary="C specific options">
<tr>
<th>C specific options</th>
</tr>

<tr>
<td>-noexcept</td>
<td>generate wrappers with no support of exception handling; see <a href="#C_exceptions">Exceptions</a> chapter for more details </td>
</tr>

</table>

<H3><a name="C_dynamic"></a>36.2.3 Compiling a dynamic module</H3>


<p>
The next step is to build a dynamically loadable module, which we can link to our application. This can be done easily, for example using the <tt>gcc</tt> compiler (Linux, MinGW, etc.):
</p>

<div class="shell"><pre>
$ swig -c example.i
$ gcc -c example_wrap.c
$ gcc -shared example_wrap.o -o libexample.so
</pre></div>

<p>
Or, for C++ input:
</p>

<div class="shell"><pre>
$ swig -c++ -c example.i
$ g++ -c example_wrap.cxx
$ g++ -shared example_wrap.o -o libexample.so
</pre></div>

<p>
Now the shared library module is ready to use. Note that the name of the generated module is important: is should be prefixed with <tt>lib</tt> on Unix, and have the specific extension, like <tt>.dll</tt> for Windows or <tt>.so</tt> for Unix systems.
</p>

<H3><a name="C_using_module"></a>36.2.4 Using the generated module</H3>


<p>
The simplest way to use the generated shared module is to link it to the application code during the compilation stage. The process is usually similar to this:
</p>

<div class="shell"><pre>
$ gcc runme.c -L. -lexample -o runme
</pre></div>

<p>
This will compile the application code (<tt>runme.c</tt>) and link it against the generated shared module. Following the <tt>-L</tt> option is the path to the directory containing the shared module. The output executable is ready to use. The last thing to do is to supply to the operating system the information of location of our module. This is system dependant, for instance Unix systems look for shared modules in certain directories, like <tt>/usr/lib</tt>, and additionally we can set the environment variable <tt>LD_LIBRARY_PATH</tt> (Unix) or <tt>PATH</tt> (Windows) for other directories.
</p>

<H2><a name="C_basic_c_wrapping"></a>36.3 Basic C wrapping</H2>


<p>
Wrapping C functions and variables is obviously performed in a straightforward way. There is no need to perform type conversions, and all language constructs can be preserved in their original form. However, SWIG allows you to enhance the code with some additional elements, for instance using <tt>check</tt> typemap or <tt>%extend</tt> directive.
</p>

<H3><a name="C_functions"></a>36.3.1 Functions</H3>


<p>
For each C function declared in the interface file a wrapper function with the prefix <tt>_wrap_</tt> is created. Basically, the wrapper function performs a call to the original function, and returns its result. For convenience, a <tt>#define func _wrap_func</tt> is also provided in the generated header file to make it possible to call the function under its original name. If this is undesirable, <tt>SWIG_NO_WRAPPER_ALIASES</tt> can be predefined before including the wrapper header to disable these defines.
</p>

<p>
For example, for function declaration:
</p>

<div class="targetlang"><pre>
int gcd(int x, int y);
</pre></div>

<p>
The output is simply:
</p>

<div class="targetlang"><pre>
int _wrap_gcd(int arg1, int arg2) {
  int result;
  result = gcd(arg1,arg2);
  return result;
}
</pre></div>

<p>
Now one might think, what's the use of creating such functions in C? The answer is, you can apply special rules to the generated code. Take for example constraint checking. You can write a "check" typemap in your interface file:
</p>

<div class="code"><pre>
%typemap(check) int POSITIVE {
  if ($1 <= 0)
    fprintf(stderr, "Expected positive value in $name.\n");
}

int gcd(int POSITIVE, int POSITIVE);
</pre></div>

<p>
And now the generated result looks like:
</p>

<div class="targetlang"><pre>
int _wrap_gcd(int arg1, int arg2) {
  {
    if (arg1 <= 0)
      fprintf(stderr, "Expected positive value in gcd.\n");
  }
  {
    if (arg1 <= 0)
      fprintf(stderr, "Expected positive value in gcd.\n");
  }
  int result;
  result = gcd(arg1,arg2);
  return result;
}
</pre></div>

<p>
This time calling <tt>gcd</tt> with negative value argument will trigger an error message. This can save you time writing all the constraint checking code by hand.
</p>

<H3><a name="C_variables"></a>36.3.2 Variables</H3>


<p>
Wrapping variables comes also without any special issues. All global variables are directly accessible from application code. There is a difference in the semantics of <tt>struct</tt> definition in C and C++. When handling C <tt>struct</tt>, SWIG simply rewrites its declaration. In C++ <tt>struct</tt> is handled as class declaration. 
</p>

<p>
You can still apply some of the SWIG features when handling structs, e.g. <tt>%extend</tt> directive. Suppose, you have a C struct declaration:
</p>

<div class="targetlang"><pre>
typedef struct {
  int x;
  char *str;
} my_struct;
</pre></div>

<p>
You can redefine it to have an additional fields, like:
</p>

<div class="code"><pre>
%extend my_struct {
  double d;
};
</pre></div>

<p>
In application code:
</p>

<div class="targetlang"><pre>
struct my_struct ms;
ms.x = 123;
ms.d = 123.123;
</pre></div>

<H2><a name="C_basic_cpp_wrapping"></a>36.4 Basic C++ wrapping</H2>


<p>
The main reason of having the C module in SWIG is to be able to access C++ from C. In this chapter we will take a look at the rules of wrapping elements of the C++ language.
</p>

<p>
By default, SWIG attempts to build a natural C interface to your C/C++ code.
<table BORDER summary="Generated C representation of C++">
  <tr>
    <th>C++ Type</th>
    <th>SWIG C Translation</th>
  </tr>
  <tr>
    <td>Class <tt>Example</tt></td>
    <td>Empty structure <tt>Example</tt></td>
  </tr>
  <tr>
    <td>Public, mutable member variable <tt><tt>Foo Example::foo</tt></td>
    <td><tt>
      Example_foo_get(Example *e);</br>
      Example_foo_set(Example *e, Foo *f);
    </tt></td>
  </tr>
  <tr>
    <td>Public, immutable member variable <tt><tt>Foo Example::bar</tt></td>
    <td><tt>
      Example_foo_get(Example *e);</br>
    </tt></td>
  </tr>
</table>
This section briefly covers the essential aspects of this wrapping.
</p>

<H3><a name="C_enums"></a>36.3.3 Enums</H3>

<p>
C enums are simply copied to the generated code and keep the same name as in
the original code.
</p>


<H3><a name="C_classes"></a>36.4.1 Classes</H3>


<p>
Consider the following example. We have a C++ class, and want to use it from C code.
</p>

<div class="targetlang"><pre>
class Circle {
public:
  double radius;

  Circle(double r) : radius(r) { };
  double area(void);
};
</pre></div>

<p>
What we need to do is to create an object of the class, manipulate it, and finally, destroy it. SWIG generates C functions for this purpose each time a class declaration is encountered in the interface file.
</p>

<p>
The first two generated functions are used to create and destroy instances of class <tt>Circle</tt>. Such instances are represented on the C side as pointers to special structs, called <tt>SwigObj</tt>. They are all "renamed" (via typedef) to the original class names, so that you can use the object instances on the C side using pointers like:
</p>

<div class="targetlang"><pre>
Circle *circle;
</pre></div>

<p>
The generated functions make calls to class' constructors and destructors, respectively. They also do all the necessary things required by the SWIG object management system in C.
</p>

<div class="targetlang"><pre>
Circle * Circle_new(double r);
void Circle_delete(Circle * self);
</pre></div>

<p>
The class <tt>Circle</tt> has a public variable called <tt>radius</tt>. SWIG generates a pair of setters and getters for each such variable:
</p>

<div class="targetlang"><pre>
void Circle_radius_set(Circle * self, double radius);
double Circle_radius_get(Circle * self);
</pre></div>

<p>
For each public method, an appropriate function is generated:
</p>

<div class="targetlang"><pre>
double Circle_area(Circle * self);
</pre></div>

<p>
You can see that in order to use the generated object we need to provide a pointer to the object instance (struct <tt>Circle</tt> in this case) as the first function argument. In fact, this struct is basically wrapping pointer to the "real" C++ object.
</p>

<p>
Our application code could look like this:
</p>

<div class="targetlang"><pre>
  Circle *c = Circle_new(1.5);
  printf("radius: %f\narea: %f\n", Circle_radius_get(c), Circle_area(c));
  Circle_delete(c);
</pre></div>

<p>
After running this we'll get:
</p>

<div class="shell"><pre>
radius: 1.500000
area: 7.068583
</pre></div>

<H2><a name="C_developer"></a>Backend Developer Documentation</H2>

<H2><a name="C_typemaps"></a>Typemaps</H2>

<table BORDER summary="C Backend Typemaps">
  <tr>
    <th>Typemap</th>
    <th>Used for</th>
  </tr>
  <tr>
      <td><tt>ctype</tt></td>
      <td>Provides types used for the C API and</br>
          Typecasts wrapper functions return values in proxy functions</br>
          <code>
              MyClass *MyClass_new(void) {</br>
              &nbsp;return (MyClass *)_wrap_MyClass_new();</br>
              }
          </code>
      </td>
  </tr>
  <tr>
    <td><tt>in</tt></td>
    <td>Mapping of wrapper functions parameters to local C++ variables</br>
       </br>
       <code>
          SwigObj* _wrap_MyClass_do(SwigObj *carg1) {</br>
            &nbsp;SomeCPPClass *arg1 = 0;</br>
            &nbsp;if (carg1)</br>
              &nbsp;&nbsp;arg1 = (SomeCPPClass*)carg1->obj</br>
            &nbsp;else</br>
              &nbsp;&nbsp;arg1 = 0;</br>
          }
       </code></td>
  </tr>
  <tr>
    <td><tt>out</tt></td>
    <td>Assigns wrapped function's return value to a dedicated return variable, packaging it into SwigObj if necessary</td>
  </tr>
  <tr>
    <td><tt>cppouttype</tt></td>
    <td>Type of the result variable used for the return value if the wrapped function is a C++ function
    </td>
  </tr>
</table>

<H3>C Typemaps, a Code Generation Walkthrough</H3>

To get a better idea of which typemap is used for which generated code, have a look at the following 'walk through'.</br>
Let's assume we have the following C++ interface file, we'd like to generate code for:

<H4>The Interface</H4>
<div class="code"><pre>
%module example

%inline
%{
  class SomeClass{};
  template &lt;typename T&gt; class SomeTemplateClass{};
  SomeClass someFunction(SomeTemplateClass&lt;int&gt; &someParameter, int simpleInt);
%}

%template (SomeIntTemplateClass) SomeTemplateClass&lt;int&gt;;
</pre></div>


What we would like to generate as a C interface of this function would be something like this:

<div class="targetlang"><pre>
// wrapper header file
typedef struct SwigObj_SomeClass SomeClass;

SomeClass * SomeClass_new();

void SomeClass_delete(SomeClass * carg1);
        
SomeClass* someFunction(SomeIntTemplateClass* carg1, int carg2);
        
        
typedef struct SwigObj_SomeIntTemplateClass SomeIntTemplateClass;
        
SomeIntTemplateClass * SomeIntTemplateClass_new();
        
void SomeIntTemplateClass_delete(SomeIntTemplateClass * carg1);
</pre></div>

<H4>The Wrapper</H4>
We'll examine the generation of the wrapper function first.

<div class="targetlang"><pre>
SWIGEXPORTC SwigObj * _wrap_someFunction(SwigObj * carg1, int carg2) {
  SomeClass * cppresult;
  SomeTemplateClass< int > *arg1 = 0 ;
  int arg2 ;
  SwigObj * result;
  
  {
    if (carg1)
    arg1 = (SomeTemplateClass< int > *) carg1->obj;
    else
    arg1 = (SomeTemplateClass< int > *) 0;
  }
  arg2 = (int) carg2;
  {
    const SomeClass &_result_ref =  someFunction(*arg1,arg2);cppresult = (SomeClass*) &_result_ref;
  }
  {
    result = SWIG_create_object(cppresult, SWIG_STR(SomeClass));
  }
  return result;
}
</pre></div>

It might be helpful to think of the way function calls are generated as a composition of building blocks.</br>
A typical wrapper will be composited with these [optional] blocks:

<ol>
<li>Prototype</li>
<li>C return value variable</li>
<li>Local variables equal to the called C++ function's parameters</li>
<li>[C++ return value variable]</li>
<li>Assignment (extraction) of wrapper parameters to local parameter copies</li>
<li>[Contract (e.g. constraints) checking]</li>
<li> C++ function call</li>
<li>[Exception handling]</li>
<li>[Assignment to C++ return value]</li>
<li>Assignment to C return value</li>
</ol>

Let's go through it step by step and start with the wrapper prototype

<div class="targetlang"><pre>
ctype                        ctype            ctype
---------                    ---------        ---
SwigObj * _wrap_someFunction(SwigObj * carg1, int carg2);
</pre></div>

As first unit of the wrapper code, a variable to hold the return value of the function is emitted to the wrapper's body

<div class="targetlang"><pre>
ctype
---------
SwigObj * result;
</pre></div>

Now for each of the C++ function's arguments, a local variable with the very same type is emitted to the wrapper's body.

<div class="targetlang"><pre>
SomeTemplateClass< int > *arg1 = 0 ;
int arg2 ;
</pre></div>

If it's a C++ function that is wrapped (in this case it is), another variable is emitted for the 'original' return value of the C++ function.</br>
At this point, we simply 'inject' behavior if it's a C++ function that is wrapped (in this case it obviously is).

<div class="targetlang"><pre>
cppouttype
-----------
SomeClass * cppresult;
</pre></div>

Next, the values of the input parameters are assigned to the local variables using the 'in' typemap.

<div class="targetlang"><pre>
{
  if (carg1)
  arg1 = (SomeTemplateClass< int > *) carg1->obj;
  else
  arg1 = (SomeTemplateClass< int > *) 0;
}
arg2 = (int) carg2;
</pre></div>

A reasonable question would be: "Why aren't the parameters assigned in the declaration of their local counterparts?"</br>
As seen above, for complex types pointers have to be verified before extracting and </br>
casting the actual data pointer from the provided SwigObj pointer.</br>
This could easily become messy if it was done in the same line with the local variable declaration.</br>
<p>
At this point we are ready to call the C++ function with our parameters.</br>
</p>
<div class="targetlang"><pre>
{
  const SomeClass &_result_ref =  someFunction(*arg1,arg2);cppresult = (SomeClass*) &_result_ref;
}
</pre></div>
Subsequently, the return value is assigned to the dedicated return value variable using the 'out' typemap
<div class="targetlang"><pre>
{
  result = SWIG_create_object(cppresult, SWIG_STR(SomeClass));
}
</pre></div>

Finally, the return value variable is returned.
<div class="targetlang"><pre>
return result;
</pre></div>

<H4>The Proxy</H4>
Compared to the wrapper code generation, the header code is very simple.</br>
Basically it contains just the declarations corresponding to the definitions
above.

<div class="targetlang"><pre>
// wrapper header file
typedef struct SwigObj_SomeClass SomeClass;

SomeClass * SomeClass_new();

void SomeClass_delete(SomeClass * carg1);

SomeClass* someFunction(SomeIntTemplateClass* carg1, int carg2);


typedef struct SwigObj_SomeIntTemplateClass SomeIntTemplateClass;

SomeIntTemplateClass * SomeIntTemplateClass_new();

void SomeIntTemplateClass_delete(SomeIntTemplateClass * carg1);
</pre></div>

<H2><a name="C_exceptions"></a>36.5 Exception handling</H2>


</body>
</html>
