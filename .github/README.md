# SWIG JavaScript Evolution

This is SWIG JavaScript Evolution, an up-to-date fork of the SWIG project.

As it name suggests, tt adds a number of features exclusive to JavaScript. It keeps the support for all languages - which are still unit-tested - but its only objective is to bring the JavaScript support up to date as JavaScript is a language that has seen tremendous growth and development over the last decade.

# Major New Features

* Interfacing with Node.js entirely through Node-API
  - Allowing for the distribution of universal pre-built binary modules, independent of the Node.js version, through npm - ie, your user types `npm install` and can start using your C++ library a few seconds later without having a build environment
  - `worker_threads` support out of the box
  - Automatic support for alternative Node.js derived frameworks such as Electron
  *(This part of SWIG JSE has already been merged in the mainline SWIG 4.2.0)*

* Automatic support for multi-threaded asynchronous execution for all C++ code through a simple flip switch
  One of the weakest points of Node.js in particular, and JavaScript in general, is its multithreading model. SWIG JSE changes this, bringing powerful multithreading support to developers coming from the Web world with no previous parallel programming experience. All locking is automatic and transparent and it includes deadlock prevention. Instead of writing:
   ```js
   const result = nativeModule.mathHeavyStuff();
   ```
   your user writes:
   ```js
   const result = await nativeModule.mathHeavyStuffAsync();
   ```
   and the code automatically runs in a separate background thread. Both CPU-heavy and I/O-heavy operations become automatically asynchronous.
  *(This part of SWIG JSE is currently being considered for merging in the mainline SWIG 4.2.0)*

* TypeScript Support

  Since its inception, TypeScript has surfed the JavaScript wave and after several iterations, it is becoming the language of choice for JavaScript development in the enterprise world - because of the additional coding discipline that it imposes. Modules produced by SWIG JSE support both JavaScript and TypeScript - and are fully typed when used from TypeScript - imposing the additional checks that are expected of TypeScript developers.

* WASM Support

  The true reason for the mass adoption of JavaScript is the fact that to this date, it remains the single language supported natively by web browsers. As more and more software moves to the web, there is a huge demand for porting legacy C/C++ software to this new *platform*. WASM is the answer to this demand, but porting C/C++ software to JavaScript also requires writing a huge amount of glue code - which is also the main object of SWIG. Thus, naturally, SWIG also evolves towards this new *platform*.

  **Just like JavaScript offers the unique possibility of directly sharing code between the front-end (the browser) and the back-end (usually Node.js, but now there are alternatives), so SWIG JSE offers the unique possibility of writing an universal JavaScript wrapper, which can be compiled to a native Node-API addon for Node.js and to a WASM binary for the browser - with the two having identical APIs and sharing every single bit of code.**

  A first project, [`magickwand.js`](https://github.com/mmomtchev/magickwand.js) has been published to `npm` as a testament to the capabilities offered by this new tool. It features the full ImageMagick-7 library - including support for multithreaded operations through `async`/`await` and TypeScript bindings - generated by about 700 lines of SWIG code that produces 400K lines of C++ code. Both the Node.js and the browser versions support `async`/`await` with an absolutely identical interface.
  
  Unlike all other supported languages, SWIG WASM does not target native code - on this platform JavaScript is the native language and the C/C++ code is the exotic environment. SWIG WASM is made possible by [`emnapi`](https://github.com/toyobayashi/emnapi) which provides a Node-API interface for interfacing with the JS engine in the browser.

* Code Splitting

  Although this feature has been mentioned many times in the past, the memory requirements of WASM compilation make it mandatory. SWIG JSE can produce separate C++ headers and multiple compilation units. At the moment only JavaScript Node-API and Javascript WASM can use this feature, but it is planned to eventually extend it to Python.


# Usage

SWIG JavaScript Evolution is currently pending a first official release which should come very soon.

You can find an example skeleton for a new project that uses a dual-build Node.js/native and browser/WASM system at [`swig-napi-example-project`](https://github.com/mmomtchev/swig-napi-example-project).

If you want to see a real-world complex project that uses `conan` to manage a large pool of dependencies - including WASM builds -  you should take a look at [`magickwand.js`](https://github.com/mmomtchev/magickwand.js) - the ImageMagick-7 bindings for JavaScript.

# Building from source

```shell
# from git
git clone https://github.com/mmomtchev/swig.git

# from a release
tar -zxvf v5.0.0.tar.gz

cd swig

# add a suffix if you want to be able to use the main trunk SWIG
# on the same host
./configure --program-suffix=-jse

# this will install everything in /usr/local/share/swig-jse
# w/o affecting your existing SWIG
make -j 4 && sudo make install
```

For WASM, you will also need to install `emsdk` and setup its environment variables as described at
https://github.com/emscripten-core/emsdk.

# JavaScript manual

The only changes in the manual relative to the mainline SWIG are in the [JavaScript](https://htmlpreview.github.io/?https://github.com/mmomtchev/swig/blob/main/Doc/Manual/Javascript.html) section.
